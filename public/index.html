<!-- public/index.html -->
<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>FantaAuction Manager</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://kit.fontawesome.com/253572e3dd.js" crossorigin="anonymous"></script>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 24px; }
    .grid { display:grid; gap:16px; grid-template-columns: 1fr; }
    .card { border:1px solid #ddd; border-radius:10px; padding:16px; }
    .row { display:grid; grid-template-columns: 1fr auto; gap:8px; margin:8px 0; }
    input, button { padding:8px; font-size:16px; }
    #status { padding:10px; border-radius:8px; background:#f5f5f5; min-height:2.2em; }
    .ok { color:#0a7a0a; } .err { color:#b00020; }
    table { width:100%; border-collapse:collapse; }
    th, td { border:1px solid #ddd; padding:6px; text-align:center; }
    .big { font-size: 28px; font-weight: 700; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    /* Fullscreen base */
    html, body { height: 100%; }

    /* Bidder layout */
    #bidderCard { display: flex; flex-direction: column; height: 100%; }
    .player-display { display: flex; align-items: center; gap: 12px; }
    .player-photo { width: 64px; height: 64px; border-radius: 50%; object-fit: cover; }
    .bidder-secondary { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin: 12px 0; }
    .info-box { background:#f7f7f7; border:1px solid #e5e5e5; border-radius:8px; padding:8px 12px; }
    .quick-bid-wrap { margin-top: auto; }
    .quick-bid { display: grid; grid-template-columns: repeat(3, minmax(140px, 1fr)); gap: 12px; }
    .bid-bottom-bar { position:fixed; bottom:0; left:0; right:0; display:none; justify-content:space-between; align-items:center; padding:8px; background:#fff; box-shadow:0 -2px 8px rgba(0,0,0,.1); z-index:9999; }

    .qbtn { position: relative; display: flex; align-items: center; justify-content: center; gap: 10px; padding: 22px 24px; border: none; border-radius: 16px;
      background: linear-gradient(135deg, #f7f7f7, #ececec); box-shadow: 0 10px 20px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.7);
      font-size: 24px; font-weight: 800; cursor: pointer; transition: transform .06s ease, box-shadow .2s ease, filter .2s ease; user-select: none; }
    .qbtn:hover { filter: brightness(1.03); } .qbtn:active { transform: translateY(1px) scale(0.99); }
    .qbtn:focus-visible { outline: 3px solid #3b82f6; outline-offset: 3px; border-radius: 18px; }
    .qbtn.q1 { background: linear-gradient(135deg, #e8f3ff, #d9ecff); }
    .qbtn.q5 { background: linear-gradient(135deg, #e7ffe8, #d7ffd9); }
    .qbtn.q10 { background: linear-gradient(135deg, #fff3e8, #ffe7d6); }
    .qbtn .chip { width: 38px; height: 38px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, #fff, #f0f0f0 60%, #e0e0e0);
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.08); display: grid; place-items: center; }
    .qbtn svg { width: 22px; height: 22px; opacity: .9; }
    .qbtn .label { display: inline-block; min-width: 58px; text-align: center; }

    @media (max-width: 600px) {
      .player-display { flex-direction: column; align-items: flex-start; }
      .quick-bid { grid-template-columns: 1fr; }
      .qbtn { width: 100%; }
      .bidder-secondary { grid-template-columns: 1fr; }
      #bidderBudgetBox, #bidderMetaBox { font-size:14px; padding:6px 8px; }
      #bidderBudgetBox div, #bidderMetaBox div { margin:2px 0; }
      #bidderNominateBox { font-size:14px; padding:10px; }
      #bidInputRow { display:none; }
      .bid-bottom-bar { display:flex; }
      #bidderCard { padding-bottom:60px; }
    }

    /* Monitor layout */
    .monitor-topbar { display: flex; justify-content: flex-end; margin-bottom: 0; }
	.assign-banner{
	  border: 2px solid #10b981;
	  background: #ecfdf5;
	  color: #065f46;
	  border-radius: 12px;
	  padding: 10px 14px;
	  font-weight: 700;
	  font-size: clamp(16px, 1.9vw, 22px);
	}
	.assign-banner--none{
	  border-color:#9ca3af;
	  background:#f3f4f6;
	  color:#374151;
	}

	.players-toolbar {
	  display: grid;
	  grid-template-columns: 1.6fr 0.9fr 1.2fr auto 1fr;
	  gap: 8px;
	  align-items: center;
	  margin: 8px 0 12px;
	}
	.players-toolbar input, .players-toolbar select { padding: 8px; }

	.players-pager {
	  display:flex; gap:8px; align-items:center; justify-content:flex-end;
	  margin-top: 10px;
	}
	.players-spacer { flex: 1; }

	
    /* Prezzo + Tempo su una riga */
    .mon-pt { display: grid; grid-template-columns: 1fr auto 1fr; gap: 8px; align-items: baseline; font-size: clamp(16px, 1.9vw, 22px); min-width: 0; }
    .mon-pt .sep { opacity: .5; }
    .mon-pt .mon-value { font-weight: 700; font-size: clamp(18px, 3.2vw, 44px); line-height: 1.15; word-break: break-word; }
    .is-fullscreen .mon-pt { font-size: clamp(18px, 2.2vw, 28px); }
    .is-fullscreen .mon-pt .mon-value { font-size: clamp(22px, 4vw, 68px); }
    @media (max-width: 600px) { .mon-pt { grid-template-columns: 1fr; gap: 6px; } .mon-pt .sep { display: none; } }

    /* Pedici */
    .suffix { font-size: 0.6em; vertical-align: sub; font-weight: 600; margin-left: 4px; }

    /* Colori ruolo */
    .role-por  { color: gold; }
    .role-dif  { color: green; }
    .role-cent { color: deepskyblue; }
    .role-att  { color: red; }

    /* Colori countdown */
    .time-warn   { color: #b45309; } /* 5→3 */
    .time-danger { color: #991b1b; } /* ≤3 */
	
	/* Layout host migliorato */
	.host-toolbar {
	  display:flex; align-items:center; justify-content:space-between;
	  gap:16px; margin-bottom:12px;
	}
	.stat-group { display:flex; flex-wrap:wrap; gap:12px; }
	.stat {
	  min-width: 140px;
	  background: #f7f7f7;
	  border:1px solid #e5e5e5;
	  border-radius: 10px;
	  padding: 10px 12px;
	}
	.stat-label { font-size:12px; color:#666; }
	.stat-value { font-size:18px; font-weight:700; }

        .host-controls { display:flex; flex-wrap:wrap; gap:8px; }

	.host-grid { display:grid; gap:16px; grid-template-columns: 1.2fr 1fr; }
	.host-grid .full { grid-column: 1 / -1; } /* ← prende tutta la riga */
	.host-col { display:flex; flex-direction:column; gap:16px; }
	
	/* Crediti iniziali full width */
	.row.row--credits {
	  grid-template-columns: 1fr; /* l’input occupa tutto */
	}

	.section {
	  border:1px solid #e5e5e5; border-radius:12px; padding:14px;
	  background:#fff;
	}
	.section-title {
	  font-weight:700; margin-bottom:10px;
	  display:flex; align-items:center; gap:10px;
	}
	.section-title::before {
	  content:""; width:8px; height:8px; border-radius:50%; background:#3b82f6;
	}

	.subgrid { display:grid; gap:16px; grid-template-columns: 1fr; }
	.subtle { font-size:12px; color:#666; margin-bottom:6px; }

	/* Tabelle grandi e comode */
	.table-wrap { border:1px solid #eee; border-radius:10px; overflow:auto; }
	.table-wrap table { width:100%; border-collapse:collapse; }
	.table-wrap th, .table-wrap td { padding:10px; }
	.table-wrap--log { max-height: 320px; } /* un po’ più alta */

	/* Pills */
	.pill-row { display:flex; flex-wrap:wrap; gap:8px; }
	.pill {
	  background:#f3f4f6; border:1px solid #e5e7eb; border-radius:999px;
	  padding:6px 10px; font-size:26px;
	}

	/* Bottoni base */
	.btn { padding:8px 12px; border-radius:8px; border:1px solid #ddd; background:#f8f8f8; cursor:pointer; }
	.btn:hover { filter:brightness(0.98); }
	.btn-primary { background:#3b82f6; color:#fff; border-color:#3b82f6; }
	.btn-ghost { background:#fff; }
	.btn-danger { background:#ef4444; color:#fff; border-color:#ef4444; }

	@media (max-width: 1080px) {
	  .host-grid { grid-template-columns: 1fr; }
	}
	
	/* Slot tutti in una riga, ben spaziati */
	.slots-row {
	  display: grid;
	  grid-template-columns: repeat(5, minmax(120px, 1fr)); /* 4 input + bottone */
	  gap: 8px;
	}
	@media (max-width: 920px) {
	  .slots-row { grid-template-columns: 1fr 1fr; }
	  .slots-row button { grid-column: 1 / -1; } /* bottone a tutta riga su schermi piccoli */
	}
	
	.login-card {
	  max-width: 420px;
	  margin: 60px auto;
	  text-align: center;
	}

	.login-card input,
	.login-card select {
	  width: 100%;
	  padding: 12px;
	  font-size: 16px;
	  border-radius: 8px;
	  border: 1px solid #ccc;
	}

	.login-card button {
	  width: 100%;
	  font-size: 18px;
	  padding: 14px;
	  border-radius: 8px;
	}
	/* Toast minimal */
	.toast-wrap {
	  position: fixed;
	  left: 50%;
	  bottom: 24px;
	  transform: translateX(-50%);
	  display: flex;
	  gap: 8px;
	  z-index: 9999;
	  pointer-events: none;
	}
	.toast {
	  pointer-events: auto;
	  background: #111;
	  color: #fff;
	  border-radius: 10px;
	  padding: 10px 14px;
	  box-shadow: 0 8px 24px rgba(0,0,0,.2);
	  font-size: 15px;
	  max-width: 90vw;
	}
	.toast--error { background:#991b1b; }
	.toast--ok    { background:#065f46; }
	.toast--warn  { background:#b45309; }
	
	/* Giocatore già chiamato: resa attenuata, ma ancora cliccabile */
	.tr-called { opacity: .45; filter: grayscale(0.6); }
	.tr-called td { color: #6b7280; }             /* grigio testo per sicurezza */
	.tr-called img { filter: grayscale(1); }      /* miniature sicuramente grigie */
	.badge-called {
	  display:inline-block; margin-left:8px; padding:2px 6px; font-size:12px;
	  border-radius:999px; background:#eee; border:1px solid #ddd;
	}

	/* Barra logout fissa in basso */
	.logout-bar {
	  position: fixed;
	  left: 0; right: 0; bottom: 0;
	  display: none;                /* nascosta finché non si è dentro */
	  gap: 12px;
	  align-items: center;
	  justify-content: center;
	  padding: 10px 14px;
	  background: rgba(17,17,17,0.9);
	  color: #fff;
	  z-index: 9998;
	}
	.logout-bar .btn { background:#fff; color:#111; border-color:#fff; }
	.logout-bar .btn-danger { background:#ef4444; border-color:#ef4444; color:#fff; }
	
	.badge-linked{
	  display:inline-block;
	  margin-left:8px;
	  padding:2px 6px;
	  font-size:12px;
	  border-radius:999px;
	  background:#ecfdf5;
	  border:1px solid #10b981;
	  color:#065f46;
	  vertical-align:baseline;
	}

	/* === Monitor v2 (stadium theme) === */
	:root{
	  --bg-1:#0b1020; --bg-2:#111a35; --glass: rgba(255,255,255,.06);
	  --border: rgba(255,255,255,.14); --text:#f7f8fc; --muted:#a8b0d6;
	  --accent:#7dd3fc; /* fallback */
	  --ok:#10b981; --warn:#f59e0b; --danger:#ef4444;
	}
	.monitor-stage{
	  min-height:100vh; padding:max(2vh,16px) max(3vw,16px);
	  background:
		radial-gradient(1200px 400px at 50% -20%, #1b2a6b33 0%, transparent 60%),
		radial-gradient(1400px 600px at 50% 110%, #0ea5e92b 0%, transparent 60%),
		linear-gradient(160deg, var(--bg-1), var(--bg-2));
	  color:var(--text);
	}
	.mon-wrap{
	  max-width:1400px; margin:0 auto;
	  display:grid; grid-template-columns: 1.25fr .9fr; gap:3vw; align-items:center;
	}
	@media (max-width:1100px){ .mon-wrap{ grid-template-columns:1fr; gap:2rem; } }

	.mon-card{
	  background:var(--glass); border:1px solid var(--border);
	  border-radius:24px; padding:clamp(16px,2vw,28px);
	  box-shadow: 0 20px 60px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
	}

	/* Header: nome + meta */
	.mon-title{
	  display:grid; gap:.5rem;
	}
	.mon-name{
	  font-weight:900; line-height:1.05;
	  font-size: clamp(28px, 6vw, 84px);
	  letter-spacing: .01em; text-wrap: balance;
	  filter: drop-shadow(0 4px 12px rgba(0,0,0,.35));
	}
	.mon-meta{
	  display:flex; flex-wrap:wrap; gap:8px;
	  font-size: clamp(14px, 1.4vw, 18px);
	  justify-content: space-around;
	}
	.pill{
	  --c: var(--muted);
	  display:inline-flex; align-items:center; gap:.5ch;
	  border:1px solid var(--border); color:var(--text);
	  background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
	  padding:6px 10px; border-radius:999px;
	}
	.pill-host {
		--c: var(--muted);
	  display:inline-flex; align-items:center; gap:.5ch;
	  border:1px solid var(--border); color:#282828;
	  padding:6px 10px; border-radius:999px;}
	.pill .dot{ width:.55em; height:.55em; border-radius:50%; background:var(--c); }

	/* Prezzo + countdown circolare */
	.mon-price-wrap{
	  display:grid; grid-template-columns:auto 1fr; gap:1rem; align-items:center;
	  margin-top: .4rem;
	}
	.mon-ring{
	  --p: 0; /* 0..1 progresso inverso tempo */
	  --col: var(--ok);
	  width:clamp(78px,7vw,110px); aspect-ratio:1/1; place-items:center; display:grid;
	  background:
		conic-gradient(var(--col) calc(var(--p)*360deg), #ffffff15 0deg);
	  border-radius:50%;
	  box-shadow: 0 10px 26px rgba(0,0,0,.35);
	  position:relative;
	}
	.mon-ring::after{
	  content:""; position:absolute; inset:7px; border-radius:50%;
	  background: rgba(0,0,0,.35); border:1px solid var(--border);
	  box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
	}
	.mon-time{
	  position:relative; z-index:1; font-weight:800;
	  font-size: clamp(20px, 3.2vw, 42px);
	}
	.mon-price{
	  font-weight:900; letter-spacing:.02em; line-height:1;
	  font-size: clamp(36px, 7vw, 92px);
	  transition: transform .18s ease, text-shadow .18s ease;
	}
	.mon-price.tick{ transform: scale(1.04); text-shadow:0 6px 18px rgba(0,0,0,.35); }

	/* Immagine */
	.mon-img{
	  display:block; width:100%; max-width:min(44vw,560px);
	  border-radius:20px; border:1px solid var(--border);
	  background:#0b0f1e; object-fit:cover;
	  box-shadow: 0 20px 60px rgba(0,0,0,.35);
	  aspect-ratio: 4/3;
	}

	/* Ultimi 3 offerenti */
	.last3{
	  display:flex; flex-wrap:wrap; gap:10px; margin-top:1rem;
	}
	.chip{
	  background:var(--glass); border:1px solid var(--border);
	  padding:8px 12px; border-radius:999px; font-weight:700;
	  font-size: clamp(14px, 1.4vw, 18px);
	}

	/* Ruolo → colore accent */
	.role-por{ --accent:#facc15; } /* giallo */
	.role-dif{ --accent:#22c55e; } /* verde  */
	.role-cent{ --accent:#38bdf8; }/* azzurro*/
	.role-att{ --accent:#ef4444; } /* rosso  */

	/* sfondo soft solo in fullscreen monitor */
	.is-fullscreen #monitorCard{
	  background:
		radial-gradient(1200px 800px at 80% -10%, rgba(59,130,246,.08), transparent 60%),
		radial-gradient(1000px 600px at -10% 110%, rgba(16,185,129,.08), transparent 55%),
		#fff;
	}
	
	/* ===== Monitor: ottimizza spazi e gerarchie tipografiche ===== */

	/* 1) Griglia: dai più spazio alla colonna info (nome+prezzo) */
	.mon-wrap{
	  grid-template-columns: 1.35fr 1fr; /* prima: 1.25fr .9fr */
	  gap: clamp(16px, 3vw, 40px);
	}

	/* 2) Titolo più “presente” + migliore resa su 2 righe */
	.mon-title{ gap: .65rem; }
	.mon-name{
	  font-size: clamp(32px, 6.8vw, 100px); /* prima max 84px */
	  line-height: 1.02;
	  letter-spacing: .01em;
	  text-wrap: balance;
	}

	/* 3) Prezzo più grande e stabile (cifre tabulari) */
	.mon-price-wrap{ 
	  grid-template-columns: auto 1fr;
	  align-items: center;
	  gap: clamp(12px, 3vw, 36px); /* più respiro tra ring e prezzo */
	  margin-top: .6rem;
	}
	.mon-price{
	  font-size: clamp(42px, 9vw, 140px); /* prima max 92px */
	  font-variant-numeric: tabular-nums; /* niente “saltelli” del numero */
	  letter-spacing: .01em;
	}

	/* 4) Countdown ring più grande e leggibile */
	.mon-ring{
	  width: clamp(90px, 9.5vw, 160px); /* prima max ~110px */
	}
	.mon-time{
	  font-size: clamp(22px, 3.8vw, 52px);
	  line-height: 1;
	}

	/* 5) Ultimi 3 offerenti: aumenta leggibilità e usa l’ampiezza */
	.last3{
	  gap: clamp(8px, 1vw, 14px);
	  margin-top: .9rem;
	}
	.chip{
	  font-size: clamp(15px, 1.8vw, 22px); /* leggermente più grande */
	}

	/* 6) Immagine: un filo più grande in layout standard */
	.mon-img{
	  max-width: min(48vw, 620px); /* prima 44vw/560px */
	  max-height: 58vh;            /* prima ~52vh */
	}

	/* 7) Fullscreen: sfrutta tutto lo schermo */
	.is-fullscreen .monitor-topbar{ display: none !important; } /* niente barra */
	.is-fullscreen .mon-wrap{
	  grid-template-columns: 1.45fr 1fr;
	  align-items: center;
	  min-height: 92vh;
	}
	.is-fullscreen .mon-name{
	  font-size: clamp(36px, 8vw, 120px);
	}
	.is-fullscreen .mon-ring{
	  width: clamp(110px, 12vw, 200px);
	}
	.is-fullscreen .mon-time{
	  font-size: clamp(28px, 4.6vw, 64px);
	}
	.is-fullscreen .mon-price{
	  font-size: clamp(56px, 12vw, 180px);
	}
	.is-fullscreen .last3{
	  max-height: 42vh;
	  font-size: clamp(18px, 2.2vw, 28px);
	}
	.is-fullscreen .mon-img{
	  max-width: 70vw;
	  max-height: 76vh;
	}


  </style>
  <script>
	// === Fullscreen helpers ===
	function isFullscreen() {
	  return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
	}
	function requestFs(el) {
	  const target = el || document.documentElement; // fallback a tutta la pagina (Safari)
	  if (target.requestFullscreen) return target.requestFullscreen();
	  if (target.webkitRequestFullscreen) return target.webkitRequestFullscreen();
	  if (target.msRequestFullscreen) return target.msRequestFullscreen();
	}
	function exitFs() {
	  if (document.exitFullscreen) return document.exitFullscreen();
	  if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
	  if (document.msExitFullscreen) return document.msExitFullscreen();
	}
	function onToggleFullscreen() {
	  const root = document.getElementById('monitorCard') || document.documentElement;
	  if (!isFullscreen()) { requestFs(root); } else { exitFs(); }
	}
	function onFsChange() {
	  const fs = !!isFullscreen();
	  document.documentElement.classList.toggle('is-fullscreen', fs); // usi già questa classe nel CSS
	  updateFsUi();
	}
	document.addEventListener('fullscreenchange', onFsChange);
	document.addEventListener('webkitfullscreenchange', onFsChange);
	document.addEventListener('msfullscreenchange', onFsChange);

	// scorciatoie comode
	const _monCard = document.getElementById('monitorCard');
	if (_monCard) _monCard.addEventListener('dblclick', onToggleFullscreen);
	document.addEventListener('keydown', (e) => {
	  const t = (e.target && e.target.tagName || '').toLowerCase();
	  if (t === 'input' || t === 'textarea') return;
	  if ((e.key || '').toLowerCase() === 'f') onToggleFullscreen();
	});
	window.onToggleFullscreen = onToggleFullscreen;

	function updateFsUi() {
	  const btn = document.getElementById('btnFullscreen');
	  if (!btn) return;
	  const fs = !!isFullscreen();
	  btn.style.display = fs ? 'none' : ''; // << nasconde il bottone in fullscreen
	  // opzionale: se vuoi, lascia sempre la stessa label
	  btn.textContent = 'Schermo intero';
	}

	// mantiene l’etichetta allineata
	document.addEventListener('fullscreenchange', updateFsUi);
	document.addEventListener('webkitfullscreenchange', updateFsUi);
	document.addEventListener('msfullscreenchange', updateFsUi);
	
	function showMonitorCard() {
	  const card = document.getElementById('monitorCard');
	  if (!card) return;
	  card.style.display = 'block';

	  const fsBtn = document.getElementById('btnFullscreen');
	  if (fsBtn && !fsBtn._bound) {
		fsBtn.addEventListener('click', onToggleFullscreen);
		fsBtn._bound = true; // evita doppi bind
	  }
	  updateFsUi();
	}
  </script>
  <script>
    // === Stato & helpers ===
    let ws = null, isHost = false;
    let currentPrice = 0, currentBidder = null, currentItem = null;
    let last3Cache = [];
    let showBidderDetails = false;
    let countdownVal = 0, tInt = null; // tInt userà requestAnimationFrame
    let playersCache = [];     // tutti i giocatori (dal CSV)
	let playersView  = [];     // giocatori attualmente mostrati (filtrati/ordinati)
	// Stato tabella giocatori (filtri/sort/paginazione)
	let playersSortKey = 'Nome';  // 'Nome' | 'Ruolo' | 'Squadra' | 'ValoreBase'
	let playersSortDir = 'asc';   // 'asc' | 'desc'
	let playersPage = 1;
	let playersPageSize = 25;
    let playersTeamsSet = new Set(); // popolato dal CSV per il filtro squadre
    let myRole = null; // 'host' | 'monitor' | 'bidder'
    let myId = null;
    let myParticipantId = null;
    let usersCache = [];
        let pendingHostLogin = false;
        let pendingJoinName = '';
        let auctionActive = false;  // true quando c’è un’asta in corso (per tutti i ruoli)
        let calledPlayers = new Set();
	
	let isConnected = false;
    let reconnectTimer = null;
    let reconnectBackoff = 2000; // parte da 2s, raddoppia fino a 20s

	
	(function captureInviteToken(){
	  const params = new URLSearchParams(location.search);
	  const t = params.get('t') || params.get('token');
	  if (t) {
		try { localStorage.setItem('inviteToken', t); } catch {}
		const clean = location.origin + location.pathname; // rimuove query
		history.replaceState({}, '', clean);
	  }
	})();

	function showLogoutBar(show=true){
	  const bar = document.querySelector('.logout-bar');
	  if (bar) bar.style.display = show ? 'flex' : 'none';
	}

	function doLogout(){
	  // pulizia dati locali
	  try { localStorage.removeItem('inviteToken'); } catch {}
	  try { localStorage.removeItem('clientId'); } catch {}
	  try { localStorage.removeItem('hostPin'); } catch {}

	  // chiudi eventuale WS
          try { if (ws && ws.readyState === WebSocket.OPEN) ws.close(1000, 'logout'); } catch {}
          ws = null; isHost = false; myRole = null; myId = null; myParticipantId = null;

	  // torna alla schermata iniziale
	  showLogoutBar(false);
	  location.href = '/';
	}

	
    function $(id){ return document.getElementById(id); }
    function setStatus(text, ok=false, err=false){ const el=$('status'); if (!el) return; el.textContent='Stato: '+text; el.className = ok?'ok':(err?'err':''); }
    function setText(id, value){ const el = $(id); if (el) el.textContent = value; }
    function hide(el){ if (el) el.style.display = 'none'; }
    function show(el){ if (el) el.style.display = 'block'; }
	
	function playerKeyFromObj(p){
	  if (!p) return '';
	  const id = p._id || p.id;
	  if (id) return 'id:'+String(id);
	  const name = (p.Nome || p.name || '').trim().toLowerCase();
	  const role = (p.Ruolo || p.role || '').trim().toLowerCase();
	  const team = (p.Squadra || p.team || '').trim().toLowerCase();
	  return `nrt:${name}|${role}|${team}`;
	}

	function keyFromNameRoleTeam(name, role, team){
	  const n = (name||'').trim().toLowerCase();
	  const r = (role||'').trim().toLowerCase();
	  const t = (team||'').trim().toLowerCase();
	  return `nrt:${n}|${r}|${t}`;
	}
	
	function nrtKeyFromParts(name, role, team){
	  const n = (name||'').trim().toLowerCase();
	  const r = (role||'').trim().toLowerCase();
	  const t = (team||'').trim().toLowerCase();
	  return `nrt:${n}|${r}|${t}`;
	}

	function addCalledForPlayerObj(p){
	  if (!p) return;
	  const id  = p._id || p.id;
	  const n   = (p.Nome || p.name || '').trim();
	  const r   = (p.Ruolo || p.role || '').trim();
	  const t   = (p.Squadra || p.team || '').trim();
	  const nrt = nrtKeyFromParts(n, r, t);

	  if (id) calledPlayers.add('id:'+String(id));
	  if (n)  calledPlayers.add('name:'+n.toLowerCase());
	  calledPlayers.add(nrt);

	  // debug
	  console.debug('[called:add]', { id, nrt, name:n });
	}

	function isPlayerCalled(p){
	  if (!p) return false;
	  const id   = p._id || p.id;
	  const name = (p.Nome || p.name || '').trim().toLowerCase();
	  const kId  = id ? ('id:'+String(id)) : null;
	  const kNrt = nrtKeyFromParts(p.Nome || p.name, p.Ruolo || p.role, p.Squadra || p.team);
	  const kNm  = name ? ('name:'+name) : null;

	  const hit = (kId && calledPlayers.has(kId)) ||
				  calledPlayers.has(kNrt) ||
				  (kNm && calledPlayers.has(kNm));

	  // debug
	  // console.debug('[called:check]', { kId, kNrt, kNm, hit });

	  return hit;
	}
	
	let invitesCache = [];
	let invitesBusy = false;

	function inviteJoinUrl(token) {
	  return `${location.origin}/?t=${encodeURIComponent(token)}`;
	}

	async function fetchInvites() {
	  const r = await fetch('/host/invite/list');
	  const j = await r.json();
	  if (!j.success || !Array.isArray(j.invites)) {
		throw new Error('Impossibile caricare gli inviti');
	  }
	  invitesCache = j.invites.map(inv => ({
		id: inv.id,
		name: inv.name || inv.participantId || '—',
		token: inv.token,
		revoked: !!inv.revoked,
		participantId: inv.participantId || null,   // 👈 AGGIUNTO
	  }));
	  renderInvitesTable();
	}
	
	function renderInvitesTable() {
	  const tb = document.getElementById('invitesBody');
	  if (!tb) return;
	  tb.innerHTML = '';

	  (invitesCache || []).forEach(inv => {
		const url = inv.token ? inviteJoinUrl(inv.token) : '';
		const inviteId = inv.id || inv._id; // compat
		const linked  = !!inv.participantId;

		const nameCellHtml = `
		  ${escapeHtml(inv.name || inv.participantId || '—')}
		  ${linked ? '<span class="badge-linked" title="Questo invito è legato a un participant salvato">linked</span>' : ''}
		`;

		const actionsHtml = inv.revoked
		  ? '<span class="badge-called">revocato</span>'
		  : `
			<button class="btn" data-invite-action="copy" data-id="${inviteId}">Copia</button>
			<button class="btn" data-invite-action="rotate" data-id="${inviteId}">Ruota</button>
			<button class="btn btn-danger" data-invite-action="revoke" data-id="${inviteId}">Revoca</button>
		  `;

		const tr = document.createElement('tr');
		tr.innerHTML = `
		  <td>${nameCellHtml}</td>
		  <td style="text-align:left">
			<input type="text" readonly value="${url}" style="width:100%" />
		  </td>
		  <td>${actionsHtml}</td>
		`;
		tb.appendChild(tr);
	  });
	}

	function setConnectionBanner(connected){
	  const bar = document.querySelector('.logout-bar');
	  if (!bar) return;
	  bar.style.display = 'flex';
	  bar.style.background = connected ? 'rgba(17,17,17,0.9)' : '#7c2d12'; // marrone/rosso quando offline
	  bar.querySelector('span').textContent = connected ? 'Sei connesso.' : 'Disconnesso. Ritento a breve…';
	  // bottone "Riconnetti" on demand
	  let btn = bar.querySelector('#reconnectBtn');
	  if (!connected) {
		if (!btn) {
		  btn = document.createElement('button');
		  btn.id = 'reconnectBtn';
		  btn.className = 'btn';
		  btn.textContent = 'Riconnetti ora';
		  btn.onclick = ()=> { cancelReconnect(); ensureWS(autoRejoin); };
		  bar.appendChild(btn);
		}
	  } else {
		if (btn) btn.remove();
	  }
	}

	function autoRejoin(){
	  // 1) preferisci il token invito se presente
	  const token = localStorage.getItem('inviteToken');
	  if (token) {
		ws.send(JSON.stringify({ type:'join-by-invite', token }));
		// se l’utente aveva selezionato host in precedenza, prova il PIN salvato
		const last = JSON.parse(localStorage.getItem('lastLogin') || '{}');
		if (last?.role === 'host' && last?.pin) {
		  ws.send(JSON.stringify({ type:'host-login', pin: last.pin }));
		}
		return;
	  }
	  // 2) fallback: usa l’ultimo login manuale salvato
          try {
                const last = JSON.parse(localStorage.getItem('lastLogin') || '{}');
                if (last?.name && last?.role) {
                  if (last.role === 'host' || last.role === 'monitor') {
                        if (last.pin) {
                          ws.send(JSON.stringify({ type:'join', name:last.name, role:'monitor', pin:last.pin }));
                          if (last.role === 'host') ws.send(JSON.stringify({ type:'host-login', pin:last.pin }));
                        }
                  }
                }
          } catch {}
	}
	
	function scheduleReconnect(){
	  if (reconnectTimer) return;
	  reconnectTimer = setTimeout(() => {
		reconnectTimer = null;
		ensureWS(autoRejoin);
		// backoff progressivo fino a 20s
		reconnectBackoff = Math.min(reconnectBackoff * 2, 20000);
	  }, reconnectBackoff);
	}

	function cancelReconnect(){
	  if (reconnectTimer) { clearTimeout(reconnectTimer); reconnectTimer = null; }
	  reconnectBackoff = 2000;
	}

	function markDisconnectedUI(){
	  isConnected = false;
	  setStatus('Disconnesso. Riconnessione…', false, true);
	  setConnectionBanner(false);
	  setBidButtonsEnabled(false);
	}



	function renderInviteUsersSelect() {
	  // Popola il <select> con gli utenti NON host
	  const sel = document.getElementById('inviteUserSelect');
	  if (!sel) return;

	  const list = (usersCache || []).filter(u => !u.isHost);
	  sel.innerHTML = list.map(u => {
		const label = escapeHtml(u.name || u.id);
		const badge = u.participantId ? '' : ' (ospite)';
		// value = participantId (se esiste), data-client-id = id di sessione
		return `<option value="${u.participantId || ''}" data-client-id="${u.id}">${label}${badge}</option>`;
	  }).join('');
	}


	document.addEventListener('visibilitychange', () => {
	  if (document.visibilityState === 'visible') {
		// se non è proprio aperto, tenta subito
		if (!ws || ws.readyState !== WebSocket.OPEN) {
		  cancelReconnect();
		  ensureWS(autoRejoin);
		}
	  }
	});
	window.addEventListener('focus', () => {
	  if (!ws || ws.readyState !== WebSocket.OPEN) {
		cancelReconnect();
		ensureWS(autoRejoin);
	  }
	});

	
	// Crea invito da nome/ruolo (utente non ancora connesso)
	document.addEventListener('click', async (e) => {
	  if (!e.target || e.target.id !== 'inviteCreateByNameBtn') return;
	  if (invitesBusy) return;
	  invitesBusy = true; e.target.disabled = true;

	  const name = (document.getElementById('invNameNew')?.value || '').trim();
	  const role = (document.getElementById('invRoleNew')?.value || 'bidder');
	  if (!name) { showToast('Inserisci un nome', 'warn'); invitesBusy = false; e.target.disabled = false; return; }

	  try {
		const r = await fetch('/host/invite/create', {
		  method: 'POST',
		  headers: {'Content-Type':'application/json'},
		  body: JSON.stringify({ name, role })
		});
		const j = await r.json();
		if (!j.success) throw new Error(j.error || 'Errore creazione invito');

		// copia subito il link costruito dal token dell'invito
		const link = inviteJoinUrl(j.invite.token);
		try { await navigator.clipboard.writeText(link); showToast('Link copiato', 'ok'); } catch {}

		// pulizia campo + refresh lista
		const inp = document.getElementById('invNameNew'); if (inp) inp.value = '';
		await fetchInvites();
		showToast('Invito creato', 'ok');
	  } catch (err) {
		showToast(err.message || 'Errore invito', 'error');
	  } finally {
		invitesBusy = false; e.target.disabled = false;
	  }
	});




	// Un solo listener per tutte le azioni (delegation)
	document.addEventListener('click', async (e) => {
	  const btn = e.target.closest('[data-invite-action]');
	  if (!btn) return;

	  const action = btn.getAttribute('data-invite-action');
	  const id = btn.getAttribute('data-id');

	  try {
		if (action === 'copy') {
		  const tr = btn.closest('tr');
		  const input = tr.querySelector('input[readonly]');
		  input.select(); input.setSelectionRange(0, 99999);
		  await navigator.clipboard.writeText(input.value);
		  showToast('Link copiato', 'ok');
		  return;
		}

		if (invitesBusy) return;
		invitesBusy = true; btn.disabled = true;

		if (action === 'revoke') {
		  await fetch('/host/invite/revoke', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ id })});
		  await fetchInvites();
		  showToast('Invito revocato', 'ok');
		} else if (action === 'rotate') {
		  await fetch('/host/invite/rotate', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ id })});
		  await fetchInvites();
		  showToast('Nuovo link generato', 'ok');
		}
	  } catch (err) {
		showToast(err.message || 'Errore invito', 'error');
	  } finally {
		invitesBusy = false; btn.disabled = false;
	  }
	});

	// Crea invito per l’utente selezionato (solo su click)
	document.addEventListener('click', async (e) => {
	  if (!e.target || e.target.id !== 'inviteCreateBtn') return;
          const sel = document.getElementById('inviteUserSelect');
          if (!sel || sel.selectedIndex < 0) { showToast('Seleziona un partecipante', 'warn'); return; }
	  if (invitesBusy) return;
	  invitesBusy = true; e.target.disabled = true;

	  try {
		const opt = sel.selectedOptions[0];
		const participantId = opt.value || null;                // può essere '' se assente
		const clientId = opt.getAttribute('data-client-id')||''; // id di sessione
		// Trova il nome visualizzato nella tabella utenti
		const user = usersCache.find(u => u.id === clientId);

		const body = participantId
		  ? { participantId, name: user?.name || '' }  // bind a participant esistente
		  : { clientId,       name: user?.name || '' }; // crea participant dal client connesso

		const r = await fetch('/host/invite/create', {
		  method: 'POST',
		  headers: {'Content-Type':'application/json'},
		  body: JSON.stringify(body)
		});
		const j = await r.json();
		if (!j.success) throw new Error(j.error || 'Errore creazione invito');

		await fetchInvites();          // refresh tabella inviti
		showToast('Invito pronto', 'ok');
	  } catch (err) {
		showToast(err.message || 'Errore invito', 'error');
	  } finally {
		invitesBusy = false; e.target.disabled = false;
	  }
	});

	// Aggiorna elenco on-demand (no polling)
	document.addEventListener('click', (e) => {
	  if (e.target && e.target.id === 'inviteRefreshBtn') fetchInvites().catch(err => showToast(err.message, 'error'));
	});

	// Popola select quando arrivano gli users
	// (nel tuo ws.onmessage, dopo broadcast user-list, chiama)
	function onUsersUpdatedForInvites() {
	  renderInviteUsersSelect();
	}


	// Marca chiamato a partire da un payload websocket
	function markCalledFromPayload(d){
	  // Host/monitor ricevono d.item {name, role, team}, bidder solo playerName.
	  if (d && d.item && d.item.name) {
		calledPlayers.add(keyFromNameRoleTeam(d.item.name, d.item.role, d.item.team));
	  } else if (d && d.playerName) {
		// fallback meno preciso se abbiamo solo il nome
		const k = `name:${String(d.playerName).trim().toLowerCase()}`;
		calledPlayers.add(k);
	  }
	}
	
	function showAssignBanner(text, isNone=false){
	  const box = document.getElementById('monAssign');
	  const txt = document.getElementById('monAssignText');
	  if (!box || !txt) return;
	  txt.textContent = text;
	  box.style.display = 'block';
	  box.classList.toggle('assign-banner--none', !!isNone);
	}

	function hideAssignBanner(){
	  const box = document.getElementById('monAssign');
	  if (!box) return; // safe guard
	  box.style.display = 'none';
	  box.classList.remove('assign-banner--none');
	}
	
	// stato
let roundMode = false;
let roundOrder = [];
let currentNominatorId = null;
window._roundNames = window._roundNames || {};

function onHostStartRound(){
  const strat = document.getElementById('roundStrategy')?.value || 'random';
  ensureWS(()=> ws.send(JSON.stringify({ type:'host:start-round', strategy: strat })));
}
function onHostStopRound(){
  ensureWS(()=> ws.send(JSON.stringify({ type:'host:stop-round' })));
}

function onToggleBidderDetails(){
  const cb = document.getElementById('toggleBidderDetails');
  const enabled = !!cb?.checked;
  ensureWS(()=> ws.send(JSON.stringify({ type:'host:set-bidder-details', enabled })));
}

function isMyTurn(){ return roundMode && myParticipantId && currentNominatorId === myParticipantId; }

function renderRoundInfo(){
  const box = document.getElementById('roundInfo'); // se hai un box host opzionale
  if (box) {
    if (!roundMode) { box.textContent = 'Round Robin: disattivato'; }
    else {
      const names = (roundOrder||[]).map(id => (window._roundNames[id] || 'Anonimo'));
      const curName = window._roundNames[currentNominatorId] || '—';
      box.textContent = `Round attivo • Ordine: ${names.join(' → ')} • Tocca a: ${curName}`;
    }
  }
}

function onBidderNominate(){
  if (!isMyTurn()) { showToast('Non è il tuo turno per nominare.', 'warn'); return; }
  if (auctionActive) { showToast('C’è già un’asta in corso.', 'warn'); return; }
  const q = (document.getElementById('nominateSearch')?.value || '').trim().toLowerCase();
  if (!q) { showToast('Inserisci il nome del giocatore.', 'warn'); return; }
  const exact = playersCache.find(p => (p.Nome||'').toLowerCase() === q);
  const cand  = exact || playersCache.find(p => (p.Nome||'').toLowerCase().includes(q));
  if (!cand) { showToast('Giocatore non trovato nel CSV.', 'error'); return; }
  ensureWS(()=> ws.send(JSON.stringify({ type:'bidder:nominate', player: cand })));
}

function renderBidderNominateBox(){
  const box = document.getElementById('bidderNominateBox');
  const turnEl = document.getElementById('roundWhoseTurn');
  const btn = document.getElementById('openNomBtn');
  if (!box || !turnEl || !btn) return;

  const curName = window._roundNames[currentNominatorId] || '—';
  turnEl.textContent = curName;

  const visible = (myRole === 'bidder' && roundMode);
  box.style.display = visible ? 'block' : 'none';

  const enable = isMyTurn() && !auctionActive;
  btn.disabled = !enable;
  btn.style.opacity = enable ? '1' : '0.6';
  btn.style.cursor  = enable ? 'pointer' : 'not-allowed';
}

// ===== Dataset nomina (view + paginazione/filtri) =====
let nomView = [];
let nomPage = 1;
let nomPageSize = 25;
let nomTeamsSet = new Set();

function nomHydrateTeams(){
  nomTeamsSet = new Set();
  for (const p of (playersCache||[])) if (p.Squadra) nomTeamsSet.add(String(p.Squadra));
  const sel = document.getElementById('nomTeamFilter');
  if (!sel) return;
  const cur = sel.value || '';
  const teams = Array.from(nomTeamsSet).sort((a,b)=> a.localeCompare(b,'it',{sensitivity:'base'}));
  sel.innerHTML = `<option value="">Tutte le squadre</option>` + teams.map(t =>
    `<option value="${escapeHtml(t)}"${t===cur?' selected':''}>${escapeHtml(t)}</option>`
  ).join('');
}

// --- (Opzionale) Popola il <select> ruoli nella modale bidder ---
// Richiede un <select id="nomRoleFilter">
function nomHydrateRoles() {
  const sel = document.getElementById('nomRoleFilter');
  if (!sel) return;

  const cur = sel.value || '';
  const collator = new Intl.Collator('it', { sensitivity: 'base' });

  const roles = [...new Set(
    (playersCache || []).map(p => (p.Ruolo || '').trim()).filter(Boolean)
  )].sort((a,b)=> collator.compare(a,b));

  sel.innerHTML = `<option value="">Tutti i ruoli</option>` +
    roles.map(r => `<option value="${escapeHtml(r)}"${r===cur?' selected':''}>${escapeHtml(r)}</option>`).join('');
}

// --- (Opzionale) Applica i filtri della modale e rerenderizza la lista nomine ---
// Richiede gli elementi: #nomSearch, #nomRoleFilter, #nomTeamFilter, #nomList (tbody/div)
function nomApplyFilters() {
  const q     = (document.getElementById('nomSearch')?.value || '').trim().toLowerCase();
  const role  = (document.getElementById('nomRoleFilter')?.value || '').trim().toLowerCase();
  const team  = (document.getElementById('nomTeamFilter')?.value || '').trim();

  const collator = new Intl.Collator('it', { sensitivity: 'base' });

  const list = (playersCache || []).filter(p => {
    const nm = (p.Nome || '').toLowerCase();
    const rl = (p.Ruolo || '').toLowerCase();
    const sq = (p.Squadra || '');

    if (q && !(nm.includes(q) || rl.includes(q) || sq.toLowerCase().includes(q))) return false;
    if (role && rl !== role) return false;
    if (team && sq !== team) return false;
    return true;
  }).sort((a,b) => collator.compare(a.Nome||'', b.Nome||''));

  const container = document.getElementById('nomList');
  if (!container) return;

  // Esempio: tbody con righe “nome / ruolo / squadra / azione”
  container.innerHTML = list.map((p, i) => `
    <tr>
      <td>${i+1}</td>
      <td>${escapeHtml(p.Nome || '')}</td>
      <td>${escapeHtml(p.Ruolo || '')}</td>
      <td>${escapeHtml(p.Squadra || '')}</td>
      <td><button class="btn" data-nominate="${escapeHtml(p._id || p.Nome || '')}">Nomina</button></td>
    </tr>
  `).join('');

  // Bind dei bottoni “Nomina” nella modale
  container.querySelectorAll('button[data-nominate]').forEach(btn => {
  btn.addEventListener('click', (e) => {
    const key = e.currentTarget.getAttribute('data-nominate');
    const player = (playersCache || []).find(p => (p._id || p.Nome) === key);
    if (!player) return;
    ensureWS(() => ws.send(JSON.stringify({ type: 'bidder:nominate', player })));
    closeNominateModal?.();
  });
});

}

function onNomSearchInput(){
  clearTimeout(onNomSearchInput._t);
  onNomSearchInput._t = setTimeout(() => {
    nomPage = 1;
    buildNomView();
    renderNomPage();
  }, 120);
}
function onNomFiltersChange(){
  nomPage = 1;
  buildNomView();
  renderNomPage();
}
function onNomPageSizeChange(){
  const sel = document.getElementById('nomPageSize');
  nomPageSize = Math.max(1, parseInt(sel.value,10) || 25);
  nomPage = 1;
  renderNomPage();
}

function buildNomView(){
  const q    = (document.getElementById('nomSearch')?.value || '').trim().toLowerCase();
  const team = (document.getElementById('nomTeamFilter')?.value || '').trim();
  const role = (document.getElementById('nomRoleFilter')?.value || '').trim();

  nomView = (playersCache || []).filter(p => {
    const nm = (p.Nome || '').toLowerCase();
    const rl = (p.Ruolo || '').toLowerCase();
    const sq = (p.Squadra || '').toLowerCase();
    if (q && !(nm.includes(q) || rl.includes(q) || sq.includes(q))) return false;
    if (team && String(p.Squadra) !== team) return false;
    if (role && rl !== role.toLowerCase()) return false;
    return true;
  }).sort((a,b)=>{
    // default: alfabetico per nome
    return (a.Nome||'').localeCompare(b.Nome||'', 'it', {sensitivity:'base'});
  });
}

function updateNomPager(total){
  const curEl = document.getElementById('nomPageCur');
  const maxEl = document.getElementById('nomPageMax');
  const cntEl = document.getElementById('nomCount');
  const max = Math.max(1, Math.ceil(total / nomPageSize));
  if (curEl) curEl.textContent = String(nomPage);
  if (maxEl) maxEl.textContent = String(max);
  if (cntEl) cntEl.textContent = String(total);
}

function nomGoPage(what){
  const max = Math.max(1, Math.ceil(nomView.length / nomPageSize));
  if (what==='first') nomPage = 1;
  else if (what==='prev') nomPage = Math.max(1, nomPage-1);
  else if (what==='next') nomPage = Math.min(max, nomPage+1);
  else if (what==='last') nomPage = max;
  renderNomPage();
}

function renderNomPage(){
  const tb = document.getElementById('nomBody');
  if (!tb) return;
  tb.innerHTML = '';

  const total = nomView.length;
  const start = Math.max(0, (nomPage-1) * nomPageSize);
  const end   = Math.min(total, start + nomPageSize);
  const rows  = nomView.slice(start, end);

  rows.forEach((p, i) => {
    const absIndex = start + i;
    const nome = p.Nome || '';
    const ruolo = p.Ruolo || '';
    const squadra = p.Squadra || '';
    const base = p.ValoreBase || 0;

    let thumb = '';
    const img = (p.Immagine || '').toString().trim();
    if (img) {
      const src = img.startsWith('/') ? img
              : /^https?:\/\//i.test(img) ? `/img-proxy?u=${encodeURIComponent(img)}`
              : '';
      if (src) thumb = `<img src="${src}" alt="" style="height:28px;width:auto;border-radius:6px;border:1px solid #eee" onerror="this.style.display='none'">`;
    }

    const canNominate = isMyTurn() && !auctionActive;

    // 👇 usa la stessa chiave e set della lista host
    const isCalled = isPlayerCalled(p);

    const tr = document.createElement('tr');
    if (isCalled) tr.classList.add('tr-called');

    tr.innerHTML = `
      <td>${absIndex+1}</td>
      <td style="display:flex;align-items:center;gap:8px;">
        ${thumb}
        <span>${escapeHtml(nome)}</span>
        ${isCalled ? '<span class="badge-called">chiamato</span>' : ''}
      </td>
      <td>${escapeHtml(ruolo)}</td>
      <td>${escapeHtml(squadra)}</td>
      <td>${base}</td>
      <td>
        <button class="btn btn-primary" data-nom-idx="${absIndex}" ${canNominate ? '' : 'disabled'}>
          ${canNominate ? 'Nomina' : '—'}
        </button>
      </td>
    `;
    tb.appendChild(tr);
  });

  tb.querySelectorAll('button[data-nom-idx]').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const i = parseInt(e.currentTarget.getAttribute('data-nom-idx'),10);
      const p = nomView[i];
      if (!p) return;
      doNominatePlayer(p);
    });
  });

  updateNomPager(total);
}


function openNominateModal(){
  if (!roundMode) { showToast('Round non attivo.', 'warn'); return; }
  if (!isMyTurn()) { showToast('Non è il tuo turno.', 'warn'); return; }
  if (auctionActive) { showToast('C’è già un’asta in corso.', 'warn'); return; }

  nomHydrateTeams();
  buildNomView();
  nomPage = 1;
  renderNomPage();

  const m = document.getElementById('nominateModal');
  if (m) m.style.display = 'block';
}

function closeNominateModal(){
  const m = document.getElementById('nominateModal');
  if (m) m.style.display = 'none';
}

function doNominatePlayer(p){
  if (!roundMode) { showToast('Round non attivo.', 'warn'); return; }
  if (!isMyTurn()) { showToast('Non è il tuo turno.', 'warn'); return; }
  if (auctionActive) { showToast('C’è già un’asta in corso.', 'warn'); return; }
  ensureWS(()=> ws.send(JSON.stringify({ type:'bidder:nominate', player: p })));
  closeNominateModal();
}
		
	// --- Toast helpers ---
	let toastWrap;
	function ensureToastWrap() {
	  if (!toastWrap) {
		toastWrap = document.createElement('div');
		toastWrap.className = 'toast-wrap';
		document.body.appendChild(toastWrap);
	  }
	}
	function showToast(msg, kind='error', ms=3000) {
	  ensureToastWrap();
	  const el = document.createElement('div');
	  el.className = 'toast ' + (kind ? `toast--${kind}` : '');
	  el.textContent = String(msg || '');
	  toastWrap.appendChild(el);
	  setTimeout(()=> {
		el.style.opacity = '0';
		el.style.transition = 'opacity .25s ease';
		setTimeout(()=> el.remove(), 250);
	  }, ms);
	}

    // ✅ LOGIN UI: bind select/btn alla load
    document.addEventListener('DOMContentLoaded', () => {
          // auto-join se ho già un invito salvato
          const token = localStorage.getItem('inviteToken');
          if (token) {
                ensureWS(() => {
                  try { ws.send(JSON.stringify({ type: 'join-by-invite', token })); } catch {}
                });
          }

          // costruzione UI + bind login
          buildUI();

          const roleSel = $('joinRole');
          const pinRow  = $('pinRow');
          const btn     = $('loginBtn');

          // Se non c'è un token d'invito, rimuovi l'opzione partecipante
          if (!token && roleSel) {
                const opt = roleSel.querySelector('option[value="bidder"]');
                if (opt) opt.remove();
          }

          if (roleSel) {
                // mostra il campo PIN per monitor e host
                const roleChange = e => {
                  const role = e.target.value;
                  pinRow.style.display = (role === 'host' || role === 'monitor') ? '' : 'none';
                };
                roleSel.addEventListener('change', roleChange);
                // stato iniziale
                roleChange({ target: roleSel });
          }
          if (btn) btn.addEventListener('click', doLogin);
          document.addEventListener('click', (e) => {
                if (e.target && e.target.id === 'logoutBtn') {
                  doLogout();
                }
          });
        });
		
		document.addEventListener('click', (e) => {
		  const btn = e.target.closest('[data-expel]');
		  if (!btn) return;

		  if (!isHost) { showToast('Solo il gestore può espellere utenti.', 'warn'); return; }

		  const clientId = btn.getAttribute('data-expel');
		  const user = (usersCache || []).find(u => u.id === clientId);
		  const nome = user?.name || clientId;

		  if (!confirm(`Espellere ${nome}?`)) return;

		  // opzionale: feedback immediato UI
		  btn.disabled = true;

		  ensureWS(() => {
			try {
			  ws.send(JSON.stringify({ type: 'host:expel', clientId }));
			  showToast(`Espulso: ${nome}`, 'ok');
			} catch {
			  btn.disabled = false;
			  showToast('Errore di invio espulsione', 'error');
			}
		  });
		});

		
		document.addEventListener('click', (e) => {
		  const el = e.target?.closest('#btnSkipNominator, #btnKickAnon');
		  if (!el) return;
		  e.preventDefault();

		  if (el.id === 'btnSkipNominator') {
			// opzionale: blocca se non sei host
			if (!isHost) { showToast('Solo il gestore può skippare.', 'warn'); return; }
			console.log('[UI] sending host:skip-nominator');
			ensureWS(() => ws.send(JSON.stringify({ type: 'host:skip-nominator' })));
		  }

		  if (el.id === 'btnKickAnon') {
			if (!isHost) { showToast('Solo il gestore può eliminare anonimi.', 'warn'); return; }
			console.log('[UI] sending host:kick-anon');
			ensureWS(() => ws.send(JSON.stringify({ type: 'host:kick-anon' })));
		  }
		});


	function renderLog(entries){
    const tb = document.getElementById('logBody');
    if (!tb) return;
    let html = '';
    for (let i = entries.length - 1; i >= 0; i--) {
      const e = entries[i];
      const time = new Date(e.time).toLocaleTimeString();
      let label = e.type;
      if (label==='bid') label='Offerta';
      if (label==='auction-start') label='Inizio';
      if (label==='auction-end') label='Fine';
      if (label==='timer-set') label='Timer';
      if (label==='kick') label='Espulsione';
      if (label==='budgets-set') label='Budget iniziali';
      if (label==='bidder-update') label='Agg. bidder';
      html += `<tr>
        <td>${time}</td>
        <td>${label}</td>
        <td>${e.item ? (e.item.name || '') : ''}</td>
        <td>${e.name || e.target || ''}</td>
        <td>${e.amount || ''}</td>
        <td>${e.winner || ''}</td>
      </tr>`;
    }
    tb.innerHTML = html;
    // ultimi eventi in alto
    const wrap = document.querySelector('.table-wrap--log');
    if (wrap) wrap.scrollTop = 0;
  }
	
    function doLogin(){
          const token = localStorage.getItem('inviteToken');
          const name  = (document.getElementById('joinName')?.value || '').trim();
          const role  = document.getElementById('joinRole')?.value || 'bidder';
          const pin   = (document.getElementById('hostPin')?.value || '').trim();

          // ⬇️ memorizza un "ultimo login" soltanto se NON stai usando un invito
          if (!token) {
                try {
                  localStorage.setItem('lastLogin', JSON.stringify({ name, role, pin: (role==='host'?pin:'') }));
                } catch {}
          }

          if (!token && role === 'bidder') {
                alert('I partecipanti devono usare un link d\'invito.');
                return;
          }

          ensureWS(() => {
                if (token) {
                  ws.send(JSON.stringify({ type:'join-by-invite', token }));
                  if (role === 'host' && pin) ws.send(JSON.stringify({ type:'host-login', pin }));
                  return;
                }
                if (!name) { alert('Inserisci il nome'); return; }

                if (role === 'monitor' || role === 'host') {
                  if (!pin) { alert('Inserisci il PIN gestore'); return; }
                  ws.send(JSON.stringify({ type:'join', name, role: 'monitor', pin }));
                  if (role === 'host') {
                        ws.send(JSON.stringify({ type:'host-login', pin }));
                  }
                  return;
                }
          });
        }



	function cryptoRandomId(){
	  const a = new Uint8Array(16);
	  (window.crypto || window.msCrypto).getRandomValues(a);
	  return Array.from(a, b=>b.toString(16).padStart(2,'0')).join('');
	}

	let pingTimer = null;
	function startClientPing(){
	  if (pingTimer) clearInterval(pingTimer);
	  pingTimer = setInterval(() => {
		try {
		  if (ws && ws.readyState === WebSocket.OPEN) {
			ws.send(JSON.stringify({ type:'ping', t: Date.now() }));
		  }
		} catch {}
	  }, 20000); // 20s
	}
	
	function stopClientPing(){
	  if (pingTimer) { clearInterval(pingTimer); pingTimer = null; }
	}

    function ensureWS(thenSend){
      if (ws && ws.readyState === WebSocket.OPEN) { thenSend && thenSend(); return; }

	  const url = (location.protocol==='https:'?'wss://':'ws://') + location.host;
	  setStatus('Connessione al server…');
	  try { if (ws) ws.close(1000); } catch {}
	  ws = new WebSocket(url);

      ws.addEventListener('open', ()=>{
		isConnected = true;
		cancelReconnect();
		setStatus('Connesso.');
		setConnectionBanner(true);
		// ping keep-alive parte/ri-parte
		startClientPing();
		// auto-rejoin (token invito o ultimo login)
		(thenSend || autoRejoin)();
	  }, { once:true });

      ws.onmessage = (e)=>{
        let d; try{ d = JSON.parse(e.data); } catch { return; }

        // 🔹 JOIN riuscito (bidder/monitor)
        if (d.type === 'joined') {
                  myRole = d.role || 'bidder';
                  if (d.clientId) myId = d.clientId;
                  if (d.participantId) myParticipantId = d.participantId;

		  // Se stiamo facendo login host, NON cambiare UI qui.
		  if (pendingHostLogin) {
			// opzionale: puoi aggiornare uno stato di attesa
			return;
		  }

		  // Altrimenti, flusso normale bidder/monitor
		  setStatus(`Benvenuto ${d.name}! (${myRole})`, true);
		  document.getElementById('loginCard')?.style?.setProperty('display', 'none');
		  if (myRole === 'bidder') {
			document.getElementById('bidderCard').style.display = 'block';
			const row = document.getElementById('bidderMetaRow'); if (row) row.style.display = 'none';
			const rowCountdown = document.getElementById('bidderCountdownRow'); if (rowCountdown) rowCountdown.style.display = 'none';
			showLogoutBar(true);
		  }
		  if (myRole === 'monitor') {
			  showMonitorCard();
		  }
		  document.getElementById('meName') && (document.getElementById('meName').textContent = d.name || '');
		  return;
        }

        if (d.type === 'show-bidder-details') {
          showBidderDetails = !!d.enabled;
          const cb = document.getElementById('toggleBidderDetails');
          if (cb) cb.checked = showBidderDetails;
          applyAuctionPayload({ type: 'state', item: showBidderDetails ? currentItem : null, playerName: currentItem ? currentItem.name : null, price: currentPrice, bidder: currentBidder, last3: last3Cache });
          return;
        }

        // update round state dentro handler “state / auction-started / new-bid”
        if (d.type === 'state' || d.type === 'auction-started' || d.type === 'new-bid') {
          if ('roundMode' in d) roundMode = !!d.roundMode;
          if ('nominationOrder' in d && Array.isArray(d.nominationOrder)) roundOrder = d.nominationOrder;
          if ('currentNominatorId' in d) currentNominatorId = d.currentNominatorId;
          if ('showBidderDetails' in d) {
            showBidderDetails = !!d.showBidderDetails;
            const cb = document.getElementById('toggleBidderDetails');
            if (cb) cb.checked = showBidderDetails;
          }
          if (Array.isArray(d.last3)) last3Cache = d.last3;
          if (d.item) currentItem = d.item;
          else if (d.playerName != null) currentItem = { ...(currentItem||{}), name: d.playerName };

          if (myRole === 'monitor') {
            setMonPrice(d.amount || d.price || 0);
            renderLast3Chips(d.last3 || []);
            // opzionale: un leggero “tick” di countdown se vuoi
            // paintFancyCountdown(d.secondsRimasti ?? ...);
          }

          if (d.type === 'new-bid' && Number.isFinite(d.seconds)) {
            startCountdown(d.seconds);
            if (myRole === 'monitor') paintFancyCountdown(d.seconds);
          }

          applyAuctionPayload(d);
          renderRoundInfo();
          renderBidderNominateBox();
          return;
        }

		// handler specifico broadcast round
		if (d.type === 'round-state') {
		  roundMode = !!d.roundMode;
		  roundOrder = Array.isArray(d.order) ? d.order : [];
		  currentNominatorId = d.current || null;
		  window._roundNames = d.names || {};
		  renderRoundInfo();
		  renderBidderNominateBox();
		  return;
		}
		
		if (d.type === 'host:skip-ack') {
		  console.log('[WS] host:skip-ack', d);
		  const msg =
			d.ok ? `Turno passato: ${d.prevName ?? '—'} → ${d.nextName ?? '—'}`
				 : `Skip non eseguito (${d.reason})`;
		  showToast(msg, d.ok ? 'ok' : 'warn');
		  // opzionale: aggiorna subito roundInfo se il server non ha già broadcastato
		  renderRoundInfo();
		  return;
		}

        // HOST autenticato
        if (d.type === 'host-auth') {
		  if (d.success) {
		  
			showLogoutBar(true);
			myRole = 'host'; isHost = true;
			if (d.clientId) myId = d.clientId;

			// fine attesa host
			pendingHostLogin = false;

			setStatus('Login gestore ✅', true);

			// mostra host, nascondi tutto il resto
			document.getElementById('loginCard')?.style?.setProperty('display', 'none');
			document.getElementById('bidderCard')?.style?.setProperty('display', 'none');
			document.getElementById('monitorCard')?.style?.setProperty('display', 'none');
			document.getElementById('hostCard')?.style?.setProperty('display', 'block');

			// chiedi subito la lista utenti
			try { ws.send(JSON.stringify({ type:'host:get-users' })); } catch {}
			renderUsers(usersCache);
		  } else {
			// PIN errato → torna alla login “normale”
			pendingHostLogin = false;
			setStatus('PIN errato ❌', false, true);
		  }
		  return;
		}


        if (d.type === 'players-list') {
		  playersCache = d.players || [];
		  renderPlayers();              // già lo fai per la vista host
		  nomHydrateTeams();            // 👈 popola il filtro squadre nella modale bidder
		  nomHydrateRoles();            // (opzionale) popola il filtro ruoli
		  nomApplyFilters();            // (opzionale) aggiorna la lista nella modale se già aperta
		  return;
		}


        if (d.type === 'user-list') {
          const base = d.users || [];
          if (isHost) {
            fetch('/host/participants/list').then(r=>r.json()).then(j=>{
              usersCache = j.participants || base;
              renderUsers(usersCache);
              renderInviteUsersSelect();
              if (myRole === 'bidder' && myParticipantId) {
                const me = usersCache.find(u => u.participantId === myParticipantId);
                if (me) updateBidderBudget(me);
              }
            }).catch(()=>{
              usersCache = base;
              renderUsers(usersCache);
              renderInviteUsersSelect();
            });
          } else {
            usersCache = base;
            renderUsers(usersCache);
            renderInviteUsersSelect();
            if (myRole === 'bidder' && myParticipantId) {
              const me = usersCache.find(u => u.participantId === myParticipantId);
              if (me) updateBidderBudget(me);
            }
          }
          return;
        }

        if (d.type === 'timer-updated') { setText('timerCur', d.seconds); }

		if (d.type === 'reset-timer') {
		  startCountdown(d.seconds);
		  if (myRole === 'monitor') {
			startFancyCountdown(d.seconds || 0);
			paintFancyCountdown(d.seconds || 0);
		  }
		  return;
		}

        if (d.type === 'auction-ended') {
		  const name = d.item?.name ?? d.playerName ?? '—';
		  if (myRole !== 'monitor') {
			const name = d.item?.name ?? d.playerName ?? '—';
		    alert(`Asta terminata: ${name} → ${d.winner} (${d.amount})`);
		  }
		  
		  // ➜ SOLO MONITOR: banner di assegnazione
		  if (myRole === 'monitor') {
			const winner = (d.winner || '').trim();
			const amount = Number(d.amount || 0);

			if (winner && winner.toLowerCase() !== 'nessuno') {
			  showAssignBanner(`Assegnato a ${winner} per ${amount} FM`);
			} else {
			  showAssignBanner(`${name}: non assegnato...`, true);
			}
		  }

		  stopCountdown();
		  renderLast3(d.last3 || []);
		  renderLast3Chips(d.last3 || []);
		  currentItem = null; 
		  currentPrice = 0; 
		  currentBidder = null;

		  // UI comuni già presenti...
		  applyAuctionPayload({ item: null, playerName: null, price: 0, name: null });

		  // stato e pulsanti
		  auctionActive = false;
		  setBidButtonsEnabled(false);

                  // Nascondi righe meta/countdown nel pannello bidder e pulisci campi
                  const metaRow = document.getElementById('bidderMetaRow');
                  const cntRow  = document.getElementById('bidderCountdownRow');
                  const roleRow = document.getElementById('bidderRoleRow');
                  const teamRow = document.getElementById('bidderTeamRow');
                  const last3Row = document.getElementById('bidderLast3Row');
                  if (metaRow) metaRow.style.display = 'none';
                  if (cntRow)  cntRow.style.display  = 'none';
                  if (roleRow) roleRow.style.display = 'none';
                  if (teamRow) teamRow.style.display = 'none';
                  if (last3Row) last3Row.style.display = 'none';
                  setText('itemPriceBid', 0);
                  setText('itemBidderBid', '—');
                  setText('itemRoleBid', '—');
                  setText('itemTeamBid', '—');
                  setText('itemLast3Bid', '—');

		  // reset colori/immagine monitor/host
		  const monRoleEl  = $('monRole');
		  const hostRoleEl = $('itemRoleHost');
		  if (monRoleEl)  monRoleEl.classList.remove('role-por','role-dif','role-cent','role-att');
		  if (hostRoleEl) hostRoleEl.classList.remove('role-por','role-dif','role-cent','role-att');
		  const imgEl = $('monImg'); if (imgEl) imgEl.src = '/placeholder.jpg';

		  renderBidderNominateBox();

		  return;
		}

        if (d.type === 'log-update' && isHost) { renderLog(d.entries||[]); return; }
        if (d.type === 'error') {
		  // Mostra un toast visibile a chiunque (bidder/monitor/host)
		  showToast(d.message || 'Errore', 'error', 3500);
		  // opzionale: continua anche ad aggiornare eventuale #status se lo usi altrove
		  setStatus(d.message || 'Errore', false, true);
		  return;
		}
        if (d.type === 'expelled') { alert('Sei stato espulso'); location.reload(); return; }
      };

      ws.addEventListener('error', ()=> setStatus('Errore WebSocket', false, true));
	  
	  ws.onclose = () => {
		stopClientPing(); 
		markDisconnectedUI();
		scheduleReconnect();
	  };
    }

    function computeMaxBid(credits, slotsByRole){
      const c = Math.max(0, Number(credits||0));
      const S = slotsByRole || {};
      const tot = Math.max(0, (S.por||0)+(S.dif||0)+(S.cen||0)+(S.att||0));
      return Math.max(0, c - Math.max(0, tot - 1));
    }
	
        function getMyUser(){
          if (!myParticipantId) return null;
          return (usersCache||[]).find(u => u.participantId === myParticipantId) || null;
        }

	function getMyMaxBid(){
	  const me = getMyUser();
	  if (!me) return 0;
	  return computeMaxBid(me.credits, me.slotsByRole);
	}


    function updateBidderBudget(me){
	  const credits = Number(me.credits || 0);
	  const initCr  = Number(me.initialCredits ?? credits);
	  const S       = me.slotsByRole || {};
	  const spent   = Math.max(0, initCr - credits);
	  const maxBid  = computeMaxBid(credits, S);

	  setText('meCredits', credits);
	  setText('meSpent', spent);
	  setText('meMaxBid', maxBid);

	  // Se hai gli indicatori slot nel pannello bidder:
	  setText('meSlotsPor', Number(S.por ?? 0));
	  setText('meSlotsDif', Number(S.dif ?? 0));
	  setText('meSlotsCen', Number(S.cen ?? 0));
	  setText('meSlotsAtt', Number(S.att ?? 0));
	}


    // Mappa ruolo → classe colore
    function roleToClass(roleText = "") {
      const r = roleText.toLowerCase();
      if (r.includes("portiere") || r.startsWith("por")) return "role-por";
      if (r.includes("difensore") || r.startsWith("dif")) return "role-dif";
      if (r.includes("centrocamp"))                     return "role-cent";
      if (r.includes("attaccante") || r.startsWith("att")) return "role-att";
      return null;
    }
	
	// 1) evidenzia il cambio prezzo (lazy lookup)
	let _lastPrice = null;
	function setMonPrice(v) {
	  const el = document.getElementById('monPrice'); // lookup quando serve
	  if (!el) { _lastPrice = v; return; }
	  if (_lastPrice !== null && _lastPrice !== v) {
		el.classList.add('tick');
		setTimeout(() => el.classList.remove('tick'), 220);
	  }
	  el.textContent = v;
	  _lastPrice = v;
	}

	// 2) countdown circolare
	const ring = document.getElementById('monRing');
	const ringTxt = document.getElementById('monTime');
	let _countdownTotal = 0;
	function startFancyCountdown(totalSeconds){
	  _countdownTotal = Math.max(1, Number(totalSeconds) || 1);
	  paintFancyCountdown(_countdownTotal); // reset pieno
	}
	function paintFancyCountdown(remainingSeconds){
	  if (!ring) return;
	  const rem = Math.max(0, Number(remainingSeconds) || 0);
	  const p = Math.max(0, Math.min(1, rem / _countdownTotal || 0));
	  ring.style.setProperty('--p', p);
	  const col = rem <= 3 ? 'var(--danger)' :
				  rem <= 5 ? 'var(--warn)'   : 'var(--ok)';
	  ring.style.setProperty('--col', col);
	  if (ringTxt) ringTxt.textContent = rem < 5 ? (rem <= 0 ? '0' : rem.toFixed(1)) : String(Math.ceil(rem));
	}

	// 3) “Ultimi 3” come chip
	function renderLast3Chips(list){
	  const box = document.getElementById('last3Chips');
	  if (!box) return;
	  box.innerHTML = '';
	  (list||[]).slice().reverse().forEach(e=>{
		const el = document.createElement('span');
		el.className = 'chip';
		el.textContent = `${e.name} • ${e.amount}`;
		box.appendChild(el);
	  });
	}


    // Applica payload d'asta (invariato dalla tua versione aggiornata)
    function applyAuctionPayload(d) {
	  const isHM = (myRole === 'host' || myRole === 'monitor');

          // Aggiorna prezzo e top bidder sempre (anche su new-bid)
          currentPrice  = Number(d.price ?? d.amount ?? currentPrice ?? 0);
          const base = Number(currentPrice) || 0;
          const bidAmountEl = $('bidAmount');
          if (bidAmountEl) bidAmountEl.value = String(base + 1);
          const bidAmountMobileEl = $('bidAmountMobile');
          if (bidAmountMobileEl) bidAmountMobileEl.value = String(base + 1);
          currentBidder = d.bidder ?? d.name ?? currentBidder ?? null;

	  // Aggiorna auctionActive SOLO quando il payload è informativo
	  // - auction-started / state -> possiamo dedurre se c'è un item
	  // - new-bid -> NON toccare auctionActive
	  // - auction-ended -> handled anche fuori, ma per sicurezza spegniamo qui
	  if (d.type === 'auction-started' || d.type === 'state') {
		  const hasItemForHM  = !!(d.item && d.item.name != null);   // host/monitor
		  const hasNameForBid = (d.playerName != null);              // bidder
		  const isActive = hasItemForHM || hasNameForBid;

		  auctionActive = isActive;

		  if (myRole === 'monitor') {
			const price = Number(d.price || 0);
			const secs  = Number(d.seconds ?? 0);

			setMonPrice(price); 

			if (isActive) {
			  if (Number.isFinite(secs) && secs > 0) {
				startFancyCountdown(secs);
				paintFancyCountdown(secs); // inizializza ring
			  } else {
				// stato senza seconds (es. solo 'state'): porta il ring a zero
				startFancyCountdown(0);
				paintFancyCountdown(0);
			  }
			  hideAssignBanner?.();        // togli il banner “assegnato”
			  renderLast3Chips([]);        // pulisci “ultimi 3”
			}
		  }

		} else if (d.type === 'auction-ended') {
		  auctionActive = false;
		}

	  
	  if ((d.type === 'auction-started' || (d.type === 'state' && (d.item || d.playerName))) && myRole === 'monitor') {
		  hideAssignBanner();
		}
		
		if (myRole === 'bidder') {
		  const me = getMyUser();
		  if (me) updateBidderBudget(me);
		}
		
		if ((d.type === 'auction-started' || d.type === 'state') && d.item && d.item.name) {
		  addCalledForPlayerObj({
			_id: d.item._id,
			Nome: d.item.name,
			Ruolo: d.item.role,
			Squadra: d.item.team
		  });
		}

	
		// Segna come chiamato il giocatore che sta iniziando l'asta
		if (d.type === 'auction-started') {
			addCalledForPlayerObj({
				_id: d.item?._id,
				Nome: d.item?.name ?? d.playerName,
				Ruolo: d.item?.role ?? '',
				Squadra: d.item?.team ?? ''
			  });
		  markCalledFromPayload(d);
		  // rerender liste se visibili
			renderPlayersPage();
			if (typeof renderNomPage === 'function') renderNomPage();
		}

	  // Nome da mostrare (non spegnere l’asta se manca su new-bid)
	  const name =
		(isHM && d.item && d.item.name != null) ? d.item.name :
		(d.playerName != null) ? d.playerName :
		(d.item && d.item.name != null ? d.item.name : null);

	  // === HOST / MONITOR ===
	  if (isHM) {
                if (d.item) {
                  // Immagine: locale (/players/xxx.jpg) oppure URL esterno (passato tramite proxy)
                  const imgEl = document.getElementById('monImg');
                  if (imgEl) {
                        const raw = (d.item?.image ?? '').toString().trim();
                        let src = '/placeholder.jpg';
                        if (raw) {
                          if (raw.startsWith('/')) {
                                src = raw; // path locale già servito da Express (es. /players/audero.jpg)
                          } else if (/^https?:\/\//i.test(raw)) {
                                src = `/img-proxy?u=${encodeURIComponent(raw)}`; // usa il proxy per evitare CORS/cache
                                // In alternativa: src = raw;
                          }
                        }
                        imgEl.src = src;
                        imgEl.onerror = () => { imgEl.onerror = null; imgEl.src = '/placeholder.jpg'; };
                  }

                  // Aggiorna anche pannello bidder
                  const bidImg = document.getElementById('itemImgBid');
                  if (bidImg) {
                        const raw = (d.item?.image ?? '').toString().trim();
                        let src = '/placeholder.jpg';
                        if (raw) {
                          if (raw.startsWith('/')) src = raw;
                          else if (/^https?:\/\//i.test(raw)) src = `/img-proxy?u=${encodeURIComponent(raw)}`;
                        }
                        bidImg.src = src;
                        bidImg.onerror = () => { bidImg.onerror = null; bidImg.src = '/placeholder.jpg'; };
                  }

                  // Testi host + monitor
                  setText('itemNameHost', d.item.name || '—');
                  setText('itemRoleHost', d.item.role || '—');
                  setText('itemTeamHost', d.item.team || '—');

                  setText('monName', d.item.name || '—');
                  setText('monRole', d.item.role || '—');
                  setText('monTeam', d.item.team || '—');

                  // Colori ruolo
                  const cls = roleToClass(d.item.role || "");
                  const monRoleEl  = $('monRole');
                  const hostRoleEl = $('itemRoleHost');
                  if (monRoleEl)  { monRoleEl.classList.remove('role-por','role-dif','role-cent','role-att'); if (cls) monRoleEl.classList.add(cls); }
                  if (hostRoleEl) { hostRoleEl.classList.remove('role-por','role-dif','role-cent','role-att'); if (cls) hostRoleEl.classList.add(cls); }
                } else if (name != null) {
                  // Solo nome (es. su 'state' minimale)
                  setText('itemNameHost', name);
                  setText('monName', name);
                  const monRoleEl  = $('monRole');  if (monRoleEl)  monRoleEl.classList.remove('role-por','role-dif','role-cent','role-att');
                  const hostRoleEl = $('itemRoleHost'); if (hostRoleEl) hostRoleEl.classList.remove('role-por','role-dif','role-cent','role-att');
		}

		// Prezzo/offerente
		setText('itemPriceHost', currentPrice);
		setMonPrice(currentPrice);
		setText('itemBidderHost', currentBidder || '—');

		// Nome visibile anche sul pannello bidder
		if (name != null) setText('itemNameBid', name);

		if (Array.isArray(d.last3)) {
		  renderLast3(d.last3);
		  renderLast3Chips(d.last3);
		}
                  if (typeof d.seconds === 'number' && d.type !== 'new-bid') startCountdown(d.seconds);

		// Abilita/disabilita i bottoni di puntata in base allo stato corrente
		setBidButtonsEnabled(auctionActive);
		return;
	  }

	  // === BIDDER ===
          if (name != null) setText('itemNameBid', name);
          const imgBid = document.getElementById('itemImgBid');
          if (imgBid) {
            if (d.item && 'image' in d.item) {
              const raw = (d.item.image || '').toString().trim();
              let src = '/placeholder.jpg';
              if (raw) {
                if (raw.startsWith('/')) src = raw;
                else if (/^https?:\/\//i.test(raw)) src = `/img-proxy?u=${encodeURIComponent(raw)}`;
              }
              imgBid.src = src;
              imgBid.onerror = () => { imgBid.onerror = null; imgBid.src = '/placeholder.jpg'; };
            } else if (d.type === 'auction-ended' || (d.type === 'state' && !d.item)) {
              imgBid.src = '/placeholder.jpg';
            }
          }
            if (typeof d.seconds === 'number' && d.type !== 'new-bid') startCountdown(d.seconds);
          const metaRow = document.getElementById('bidderMetaRow');
          const cntRow  = document.getElementById('bidderCountdownRow');
          const roleRow = document.getElementById('bidderRoleRow');
          const teamRow = document.getElementById('bidderTeamRow');
          const last3Row = document.getElementById('bidderLast3Row');

          if (showBidderDetails) {
            if (metaRow) { metaRow.style.display = 'block'; setText('itemPriceBid', currentPrice); setText('itemBidderBid', currentBidder || '—'); }
            if (cntRow)  cntRow.style.display = 'block';
            if (roleRow) { roleRow.style.display = 'block'; setText('itemRoleBid', d.item?.role || currentItem?.role || '—'); }
            if (teamRow) { teamRow.style.display = 'block'; setText('itemTeamBid', d.item?.team || currentItem?.team || '—'); }
            if (last3Row) {
              last3Row.style.display = 'block';
              const l3 = d.last3 || last3Cache || [];
              const txt = l3.map(e => `${e.name} (${e.amount})`).join(', ');
              setText('itemLast3Bid', txt || '—');
            }
          } else {
            if (metaRow) { metaRow.style.display = 'none'; setText('itemPriceBid', 0); setText('itemBidderBid', '—'); }
            if (cntRow)  { cntRow.style.display = 'none'; setText('countdownBid', '—'); }
            if (roleRow) { roleRow.style.display = 'none'; setText('itemRoleBid', '—'); }
            if (teamRow) { teamRow.style.display = 'none'; setText('itemTeamBid', '—'); }
            if (last3Row) { last3Row.style.display = 'none'; setText('itemLast3Bid', '—'); }
          }

          // Non spegnere su new-bid: usa lo stato calcolato sopra
          setBidButtonsEnabled(auctionActive);
        }



    function renderLast3(list){
      const ul = $('last3'); if (!ul) return;
      ul.innerHTML = '';
      (list || []).slice().reverse().forEach(entry => {
        const li = document.createElement('li');
        li.textContent = `${entry.name} — ${entry.amount}`;
        ul.appendChild(li);
      });
    }

    // Countdown con decimi <5s, colori e zero finale garantito
    function startCountdown(seconds){
      const endAt = performance.now() + Math.max(0, seconds) * 1000
      stopCountdown();
	  
	  startFancyCountdown(seconds);

      const elMon  = $('monTime');
      const elHost = $('countdownHost');
      const elBid  = $('countdownBid');

      function paint(msLeft){
        if (msLeft < 0) msLeft = 0;
        const secs = msLeft / 1000;

        const warn   = (secs <= 5 && secs > 3);
        const danger = (secs <= 3);
        [elMon, elHost].forEach(el=>{
          if (!el) return;
          el.classList.remove('time-warn','time-danger');
          if (danger) el.classList.add('time-danger');
          else if (warn) el.classList.add('time-warn');
        });

        let display;
        if (secs < 5) {
          const tenthsDown = Math.floor(secs * 10 + 1e-6) / 10;
          display = (tenthsDown <= 0) ? "0" : tenthsDown.toFixed(1);
        } else {
          display = String(Math.ceil(secs));
        }

        if (elMon)  elMon.textContent  = display;      // pedice "s" è nel DOM
        if (elHost) elHost.textContent = display + 's';
        if (elBid)  elBid.textContent  = display + 's';
		
		paintFancyCountdown(secs);
	  }

      function tick(now){
        const msLeft = endAt - now;
        if (msLeft <= 0) {
          paint(0);
          stopCountdown();
          return;
        }
        paint(msLeft);
        tInt = requestAnimationFrame(tick);
      }

      paint(endAt - performance.now());
      tInt = requestAnimationFrame(tick);
    }

    function stopCountdown(){
      if (tInt) {
        try { cancelAnimationFrame(tInt); } catch {}
        try { clearInterval(tInt); } catch {}
        tInt = null;
      }
      const elMon  = $('monTime');
      const elHost = $('countdownHost');
      [elMon, elHost].forEach(el=>{
        if (!el) return;
        el.classList.remove('time-warn','time-danger');
      });
    }

    function onAdjCredits(clientId, delta){
      ensureWS(()=> ws.send(JSON.stringify({ type:'host:update-bidder', clientId, creditsDelta: delta })));
    }
    function onAdjSlotRole(clientId, role, delta){
      ensureWS(()=> ws.send(JSON.stringify({ type:'host:update-bidder', clientId, slotsDeltaRole: { role, delta } })));
    }

        function renderUsers(list){
          const tb = $('users'); if (!tb) return;
          tb.innerHTML = '';

          (list||[]).forEach(u=>{
                const S = u.slotsByRole || { por:0, dif:0, cen:0, att:0 };
                const credits = Number(u.credits ?? 0);
                const initCr  = Number(u.initialCredits ?? credits);
                const spent   = Math.max(0, initCr - credits);

                const tr = document.createElement('tr');
                tr.innerHTML = `
                  <td>${escapeHtml(u.name || '—')}<br><small>${escapeHtml(u.participantId || '')}</small></td>
                  <td>${escapeHtml(u.isHost ? 'Gestore' : (u.role || 'bidder'))}</td>
                  <td>${u.online ? '🟢 online' : '⚪ offline'}</td>
                  <td class="mono">${credits}</td>
                  <td class="mono">${spent}</td>
                  <td class="mono">${Number(S.por ?? 0)}</td>
                  <td class="mono">${Number(S.dif ?? 0)}</td>
                  <td class="mono">${Number(S.cen ?? 0)}</td>
                  <td class="mono">${Number(S.att ?? 0)}</td>
                  <td></td>
                `;

                const tdActions = tr.lastElementChild;

                const isMe = (u.participantId === myParticipantId);

                // helper per creare bottoni coerenti
                const addBtn = (label, cb, { title='', className='btn', disabled=false, ariaLabel='' } = {}) => {
                  const b = document.createElement('button');
                  b.textContent = label;
                  b.className = className;
                  if (title) b.title = title;
                  if (ariaLabel) b.setAttribute('aria-label', ariaLabel);
                  b.disabled = !!disabled;
                  b.onclick = cb;
                  return b;
                };

                // Azioni solo se NON host e online
                if (!u.isHost && u.online) {
                  // Crediti ±
                  tdActions.append(
                        addBtn('−10', ()=> onAdjCredits(u.id, -10), { title:'-10 crediti', ariaLabel:`Riduci 10 crediti a ${u.name||'utente'}` }),
			addBtn('−1',  ()=> onAdjCredits(u.id, -1),  { title:'-1 credito',  ariaLabel:`Riduci 1 credito a ${u.name||'utente'}` }),
			addBtn('+1',  ()=> onAdjCredits(u.id, +1),  { title:'+1 credito',  ariaLabel:`Aumenta 1 credito a ${u.name||'utente'}` }),
			addBtn('+10', ()=> onAdjCredits(u.id, +10), { title:'+10 crediti', ariaLabel:`Aumenta 10 crediti a ${u.name||'utente'}` }),
			document.createTextNode(' | ')
		  );

		  // Slot per ruolo ±
		  [['POR','por'], ['DIF','dif'], ['CEN','cen'], ['ATT','att']].forEach(([lbl, key]) => {
			tdActions.append(
			  addBtn(`${lbl}−`, ()=> onAdjSlotRole(u.id, key, -1), { title:`Slot ${lbl} -1`, ariaLabel:`Rimuovi uno slot ${lbl} a ${u.name||'utente'}` }),
			  addBtn(`${lbl}+`, ()=> onAdjSlotRole(u.id, key, +1), { title:`Slot ${lbl} +1`, ariaLabel:`Aggiungi uno slot ${lbl} a ${u.name||'utente'}` })
			);
		  });

		  tdActions.append(document.createTextNode(' | '));

		  // Espelli singolo giocatore (solo se l'host è collegato e non stiamo espellendo noi stessi)
		  const canKick = isHost && !isMe;
		  tdActions.append(
			addBtn('Espelli', () => {
			  // doppia guardia
			  if (!canKick) return;
			  const nm = u.name || 'partecipante';
			  const ok = confirm(`Espellere "${nm}" dalla sessione?`);
			  if (!ok) return;

			  ensureWS(() => {
				try {
				  ws.send(JSON.stringify({ type: 'host:expel', clientId: u.id }));
				  // server:
				  //  - chiude la ws del target
				  //  - pushLog({type:'kick', ...})
				  //  - broadcastUsers()
				  //  - il 'close' del client espulso ripulisce nominationOrder/currentNominator e fa broadcastRoundState()
				  // lato UI riceverai: user-list/round-state aggiornati
				} catch (e) {
				  console.error('Expel send error', e);
				}
			  });
			}, {
			  title: 'Espelli partecipante',
			  className: 'btn btn-danger',
			  disabled: !canKick,
			  ariaLabel: `Espelli ${u.name || 'partecipante'}`
			})
		  );
		}

		tb.appendChild(tr);
	  });
	}

    // === Giocatori (CSV) ===
    // --- helper locali per normalizzare una riga CSV ---
        function normalizeKeysFront(obj) {
          const out = {};
          for (const k in obj) {
                const nk = k.replace(/^\uFEFF/, '').trim(); // rimuove BOM + spazi
                out[nk] = obj[k];
          }
          return out;
        }
        const ROLE_MAP = { A:'Attaccante', D:'Difensore', C:'Centrocampista', P:'Portiere' };
        function canonicalRowFront(row) {
          if (Array.isArray(row) || Object.keys(row).some(k => /^\d+$/.test(k))) {
            const arr = Array.isArray(row)
              ? row
              : Object.keys(row).sort((a, b) => a - b).map(k => row[k]);
            const Nome    = (arr[1]  ?? '').toString().trim();
            const rawRole = (arr[3]  ?? '').toString().trim();
            const Ruolo   = ROLE_MAP[(rawRole || '').toUpperCase()] || rawRole;
            const Squadra = (arr[9]  ?? '').toString().trim();
            const Immagine = (arr[15] ?? '').toString().trim();
            return { Nome, Ruolo, Squadra, ValoreBase: 0, Immagine };
          }
          const r = normalizeKeysFront(row);
          const Nome     = (r.Nome ?? r.nome ?? r.NOME ?? r.Player ?? r.Giocatore ?? '').toString().trim();
          const rawRole  = (r.Ruolo ?? r.ruolo ?? r.Role ?? '').toString().trim();
          const Ruolo    = ROLE_MAP[(rawRole || '').toUpperCase()] || rawRole;
          const Squadra  = (r.Squadra ?? r.squadra ?? r.Team ?? '').toString().trim();
          const VBraw    = (r.ValoreBase ?? r['Valore Base'] ?? r.Base ?? r.base ?? 0);
          const ValoreBase = Number.parseInt(String(VBraw).replace(',', '.'), 10) || 0;
          const Immagine = (r.Immagine ?? r.Image ?? r.Foto ?? r.Photo ?? r.img ?? r.image ?? '').toString().trim();
          return { Nome, Ruolo, Squadra, ValoreBase, Immagine };
        }

	function onUploadCsv(){
	  const f = $('csvFile')?.files?.[0];
	  if (!f) { setStatus('Seleziona un CSV', false, true); return; }
	  const fd = new FormData();
	  fd.append('csv', f);

	  fetch('/upload', { method:'POST', body: fd })
		.then(r => r.json())
		.then(j => {
		  if (!j.success) throw new Error(j.error || 'Upload fallito');

		  const raw = Array.isArray(j.players) ? j.players : [];
		  playersCache = raw.map(canonicalRowFront).filter(p => p.Nome);
		  calledPlayers = new Set();

		  // opzionale: id stabile per debug
		  let autoinc = 1;
		  playersCache.forEach(p => { if (!p._id) p._id = `p_${autoinc++}`; });

		  setStatus(`CSV caricato ✅ (${playersCache.length} giocatori)`, true);
		  renderPlayers(); // userà la view
		  nomHydrateTeams();
		  nomHydrateRoles();
		  nomApplyFilters();
		})
		.catch(e => setStatus('Errore upload CSV: '+e.message, false, true));
	}


	
	function hydrateTeamsFilter() {
	  const sel = document.getElementById('playerTeamFilter');
	  if (!sel) return;
	  const cur = sel.value || '';
	  const teams = Array.from(playersTeamsSet).sort((a,b)=> a.localeCompare(b, 'it', {sensitivity:'base'}));
	  sel.innerHTML = `<option value="">Tutte le squadre</option>` +
		teams.map(t => `<option value="${escapeHtml(t)}"${t===cur?' selected':''}>${escapeHtml(t)}</option>`).join('');
	}

	// sicurezza minimale per valori testuali
	function escapeHtml(s=''){
	  return String(s)
		.replaceAll('&','&amp;').replaceAll('<','&lt;')
		.replaceAll('>','&gt;').replaceAll('"','&quot;')
		.replaceAll("'",'&#039;');
	}

	function onPlayersSearchInput(e) {
	  // debounce molto semplice
	  clearTimeout(onPlayersSearchInput._t);
	  onPlayersSearchInput._t = setTimeout(() => {
		playersPage = 1;
		applyPlayersFiltersAndSort();
		renderPlayersPage();
	  }, 120);
	}

	function onPlayersFilterChange() {
	  playersPage = 1;
	  applyPlayersFiltersAndSort();
	  renderPlayersPage();
	}

	function onPlayersPageSizeChange() {
	  const sel = document.getElementById('playerPageSize');
	  playersPageSize = Math.max(1, parseInt(sel.value, 10) || 25);
	  playersPage = 1;
	  renderPlayersPage();
	}

	function onPlayersSort(th) {
	  const key = th?.dataset?.sort || 'Nome';
	  if (playersSortKey === key) {
		playersSortDir = (playersSortDir === 'asc') ? 'desc' : 'asc';
	  } else {
		playersSortKey = key;
		playersSortDir = 'asc';
	  }
	  applyPlayersFiltersAndSort();
	  renderPlayersPage();

	  // feedback visivo minimale nell’header (freccina)
	  const thead = th.closest('thead');
	  if (thead) {
		thead.querySelectorAll('th').forEach(el => el.removeAttribute('data-sortdir'));
		th.setAttribute('data-sortdir', playersSortDir);
	  }
	}

	function playersGoPage(what) {
	  const total = (playersView || []).length;
	  const max   = Math.max(1, Math.ceil(total / Math.max(1, playersPageSize)));

	  if (what === 'first') playersPage = 1;
	  else if (what === 'prev') playersPage = Math.max(1, playersPage - 1);
	  else if (what === 'next') playersPage = Math.min(max, playersPage + 1);
	  else if (what === 'last') playersPage = max;

	  renderPlayersPage();
	}

	function applyPlayersFiltersAndSort(){
	  const q     = (document.getElementById('playerSearch')?.value || '').trim().toLowerCase();
	  const team  = (document.getElementById('playerTeamFilter')?.value || '').trim();
	  const role  = (document.getElementById('playerRoleFilter')?.value || '').trim();
	  const sortK = (document.getElementById('playerSort')?.value || 'name-asc');

	  // 1) filtro
	  playersView = (playersCache || []).filter(p => {
		const nm = (p.Nome || '').toLowerCase();
		const rl = (p.Ruolo || '').toLowerCase();
		const sq = (p.Squadra || '').toLowerCase();

		if (q && !(nm.includes(q) || rl.includes(q) || sq.includes(q))) return false;
		if (team && String(p.Squadra) !== team) return false;
		if (role && String(p.Ruolo).toLowerCase() !== role.toLowerCase()) return false;

		return true;
	  });

	  // 2) ordinamento
	  const collator = new Intl.Collator('it', { sensitivity: 'base' });
	  playersView.sort((a,b) => {
		switch (sortK) {
		  case 'base-asc':  return (a.ValoreBase||0) - (b.ValoreBase||0);
		  case 'base-desc': return (b.ValoreBase||0) - (a.ValoreBase||0);
		  case 'name-desc': return collator.compare(b.Nome||'', a.Nome||'');
		  case 'name-asc':
		  default:          return collator.compare(a.Nome||'', b.Nome||'');
		}
	  });

	  // riparti dalla prima pagina quando cambi filtro/sort
	  playersPage = 1;
	}

	function renderPlayersPage(){
	  const tb = document.getElementById('playersBody');
	  if (!tb) return;
	  tb.innerHTML = '';

	  const total = (playersView || []).length;
	  const max   = Math.max(1, Math.ceil(total / Math.max(1, playersPageSize)));
	  // clamp della pagina corrente, per sicurezza
	  playersPage = Math.min(max, Math.max(1, playersPage));

	  const start = (playersPage - 1) * playersPageSize;
	  const end   = Math.min(total, start + playersPageSize);
	  const slice = playersView.slice(start, end);

	  slice.forEach((p, i) => {
		const rowIndexInView = start + i;
		const nome    = p.Nome || '';
		const ruolo   = p.Ruolo || '';
		const squadra = p.Squadra || '';
		const base    = p.ValoreBase || 0;

		let thumb = '';
		const img = (p.Immagine || '').toString().trim();
		if (img) {
		  const src = img.startsWith('/') ? img :
					  /^https?:\/\//i.test(img) ? `/img-proxy?u=${encodeURIComponent(img)}` : '';
		  if (src) thumb = `<img src="${src}" alt="" style="height:36px;width:auto;border-radius:6px;border:1px solid #eee" onerror="this.style.display='none'">`;
		}

		// stato "già chiamato"
		const isCalled = isPlayerCalled(p);

		const tr = document.createElement('tr');
		if (isCalled) tr.classList.add('tr-called');
		tr.innerHTML = `
		  <td>${rowIndexInView+1}</td>
		  <td style="display:flex;align-items:center;gap:8px;">
			${thumb}
			<span>${escapeHtml(nome)}</span>
			${isCalled ? '<span class="badge-called">chiamato</span>' : ''}
		  </td>
		  <td>${escapeHtml(ruolo)}</td>
		  <td>${escapeHtml(squadra)}</td>
		  <td>${base}</td>
		  <td><button class="btn btn-ghost" data-view-index="${rowIndexInView}">${isCalled ? 'Riavvia' : 'Avvia'}</button></td>
		`;
		tb.appendChild(tr);
	  });

	  // bind
	  tb.querySelectorAll('button[data-view-index]').forEach(btn => {
		btn.addEventListener('click', (e) => {
		  const viewIdx = parseInt(e.currentTarget.getAttribute('data-view-index'), 10);
		  onStartPlayerFromView(viewIdx);
		});
	  });

	  updatePlayersPager(total);
	}

	function updatePlayersPager(total){
	  const pageMax = Math.max(1, Math.ceil(total / Math.max(1, playersPageSize)));
	  const curEl   = document.getElementById('playersPageCur');
	  const maxEl   = document.getElementById('playersPageMax');
	  const countEl = document.getElementById('playersCount');

	  if (curEl)   curEl.textContent   = String(playersPage);
	  if (maxEl)   maxEl.textContent   = String(pageMax);
	  if (countEl) countEl.textContent = String(total);
	}


	function onStartPlayerFromView(viewIndex){
	  const p = playersView[viewIndex];
	  if (!p) { showToast?.('Giocatore non trovato.', 'error'); return; }
	  // marca subito localmente
	  addCalledForPlayerObj(p);

	  // 👉 rerender immediato liste
	  renderPlayersPage();
	  if (typeof renderNomPage === 'function') renderNomPage();

	  ensureWS(()=> ws.send(JSON.stringify({ type:'host:start-player', player: p })));
	}


	// “Avvia” deve puntare all’indice corretto in playersCache, non nella pagina
	function onStartPlayerAbsolute(absIndex) {
	  const p = playersCache[absIndex] || {};
	  addCalledForPlayerObj(p);

	  // 👉 rerender immediato liste
	  renderPlayersPage();
	  if (typeof renderNomPage === 'function') renderNomPage();

	  ensureWS(()=> ws.send(JSON.stringify({ type:'host:start-player', player: p })));
	}


	function renderPlayers() {
	  // 1) ricostruisci l’insieme squadre (per dropdown) e normalizza valore ricerca
	  playersTeamsSet = new Set();
	  for (const p of (playersCache || [])) {
		if (p.Squadra) playersTeamsSet.add(String(p.Squadra));
	  }
	  hydrateTeamsFilter(); // aggiorna <select> squadre

	  // 2) applica filtri + sort
	  applyPlayersFiltersAndSort();

	  // 3) render della pagina corrente
	  renderPlayersPage();
	}



    // === Azioni host/bidder ===
    function onSetTimer(){
      const sec = Math.max(5, parseInt($('timerInp')?.value||'30',10));
      ensureWS(()=> ws.send(JSON.stringify({ type:'host:set-timer', seconds: sec })));
    }
    function onStartItem(){
      const name = ($('itemNameInp')?.value||'').trim() || 'Senza titolo';
      const startPrice = Math.max(0, parseInt($('startPriceInp')?.value||'0',10));
      const role = ($('roleInp')?.value||'').trim();
      const team = ($('teamInp')?.value||'').trim();
      const image = '';
      ensureWS(()=> ws.send(JSON.stringify({ type:'host:start-item', name, startPrice, role, team, image })));
    }
    function onStartPlayer(idx){
      const p = playersCache[idx] || {};
      ensureWS(()=> ws.send(JSON.stringify({ type:'host:start-player', player: p })));
    }
    function onEndItem(){ ensureWS(()=> ws.send(JSON.stringify({ type:'host:end-item' }))); }

    function onBidPlus(delta){
          if (!auctionActive) { showToast('Nessun giocatore in asta.', 'warn'); return; }

          const base = Number(currentPrice) || 0;
          const max  = getMyMaxBid();

          let next = base + delta;
          if (next > max) {
                if (max <= base) {
                  showToast('Hai raggiunto il tuo limite di puntata.', 'warn');
                  return;
                }
                // aggancia al massimo consentito
                next = max;
                showToast(`Offerta agganciata al tuo massimo: ${next}`, 'ok', 1800);
          }

          const inp = $('bidAmount');
          if (inp) inp.value = String(next);
          const mob = $('bidAmountMobile');
          if (mob) mob.value = String(next);

          ensureWS(()=> ws.send(JSON.stringify({ type:'bid', amount: next })));
        }

        function onBidMobilePlus(){
          if (!auctionActive) { showToast('Nessun giocatore in asta.', 'warn'); return; }

          const base = Number(currentPrice) || 0;
          const max  = getMyMaxBid();
          let val = parseInt($('bidAmountMobile')?.value || '', 10);

          if (Number.isFinite(val) && val > base) {
                if (val > max) {
                  if (max <= base) {
                        showToast('Hai raggiunto il tuo limite di puntata.', 'warn');
                        return;
                  }
                  val = max;
                  showToast(`Offerta agganciata al tuo massimo: ${val}`, 'ok', 1800);
                }
                const inp = $('bidAmount');
                const mob = $('bidAmountMobile');
                if (inp) inp.value = String(val);
                if (mob) mob.value = String(val);
                ensureWS(()=> ws.send(JSON.stringify({ type:'bid', amount: val })));
          } else {
                onBidPlus(1);
          }
        }

        function onBidCustom(){
          if (!auctionActive) { showToast('Nessun giocatore in asta.', 'warn'); return; }

          const base = Number(currentPrice) || 0;
          const max  = getMyMaxBid();
          let val = parseInt($('bidAmount')?.value||'0',10);

	  if (!Number.isFinite(val) || val <= 0) {
		showToast('Inserisci un importo valido.', 'warn'); return;
	  }
	  if (val <= base) {
		showToast('Devi superare l’offerta corrente.', 'warn'); return;
	  }
	  if (val > max) {
		if (max <= base) {
		  showToast('Hai raggiunto il tuo limite di puntata.', 'warn'); return;
		}
		val = max;
		showToast(`Offerta agganciata al tuo massimo: ${val}`, 'ok', 1800);
	  }

	  ensureWS(()=> ws.send(JSON.stringify({ type:'bid', amount: val })));
	}


	function setBidButtonsEnabled(enabled){
	  // quick-bid
	  document.querySelectorAll('.qbtn').forEach(btn=>{
		btn.disabled = !enabled;
		btn.style.opacity = enabled ? '1' : '0.6';
		btn.style.cursor  = enabled ? 'pointer' : 'not-allowed';
	  });
	  // bottone "Punta" accanto a #bidAmount
	  const customBtn = document.querySelector('#bidAmount + button');
	  if (customBtn) {
		customBtn.disabled = !enabled;
		customBtn.style.opacity = enabled ? '1' : '0.6';
		customBtn.style.cursor  = enabled ? 'pointer' : 'not-allowed';
	  }
	}

	async function loadLogList() {
  try {
    const res = await fetch('/logs/list');
    const j = await res.json();
    const sel = document.getElementById('logFileSelect');
    const btn = document.getElementById('logDownloadBtn');
    if (!sel || !btn) return;

    if (!j.success) throw new Error(j.error || 'Errore elenco log');

    sel.innerHTML = j.files.map(f => `<option value="${f}">${f}</option>`).join('');
    if (j.files.length) {
      btn.href = '/logs/file/' + encodeURIComponent(j.files[0]);
      btn.download = j.files[0];
    } else {
      btn.href = '#';
      btn.removeAttribute('download');
    }

    sel.onchange = () => {
      const name = sel.value;
      btn.href = '/logs/file/' + encodeURIComponent(name);
      btn.download = name;
    };
  } catch (e) {
    showToast('Errore caricamento elenco log: ' + e.message, 'error');
  }
}

// opzionale: carica l’elenco appena il gestore apre la dashboard
document.addEventListener('DOMContentLoaded', () => {
  const mo = new MutationObserver(() => {
    if (document.getElementById('hostCard')?.style.display !== 'none') {
      fetchInvites().catch(err => showToast(err.message, 'error'));
      mo.disconnect();
    }
  });
  mo.observe(document.body, { childList:true, subtree:true });
});



    function onSetBudgets(){
      const cr  = Math.max(0, parseInt($('defCreditsInp')?.value || '0', 10));
      const por = Math.max(0, parseInt($('defPorInp')?.value || '3', 10));
      const dif = Math.max(0, parseInt($('defDifInp')?.value || '8', 10));
      const cen = Math.max(0, parseInt($('defCenInp')?.value || '8', 10));
      const att = Math.max(0, parseInt($('defAttInp')?.value || '6', 10));
      ensureWS(()=> ws.send(JSON.stringify({
        type:'host:set-budgets',
        credits: cr,
        slotsPor: por, slotsDif: dif, slotsCen: cen, slotsAtt: att
      })));
    }

    // === Costruzione UI iniziale (il tuo markup) ===
    function buildUI(){
      const root = document.createElement('div');
      root.className = 'grid';
      root.innerHTML = `
        <!-- LOGIN CARD -->
        <div class="card login-card" id="loginCard">
          <div class="section">
            <div class="section-title">Entra nell'asta</div>
            <div class="row"><input id="joinName" type="text" placeholder="Il tuo nome" /></div>
            <div class="row">
              <select id="joinRole">
                <option value="bidder">Partecipante</option>
                <option value="monitor">Monitor esterno</option>
                <option value="host">Gestore</option>
              </select>
            </div>
            <div class="row" id="pinRow" style="display:none;">
              <input id="hostPin" type="password" placeholder="PIN gestore" />
            </div>
            <div class="row"><button class="btn btn-primary" id="loginBtn">Entra</button></div>
          </div>
        </div>

        <!-- HOST CARD -->
        <div class="card" id="hostCard" style="display:none;">
		  <!-- Toolbar / stat -->
		  <div class="host-toolbar">
                        <div class="stat-group">
                          <div class="stat">
                                <div class="stat-label">In corso</div>
                                <div class="stat-value">
                                  <span id="itemNameHost">—</span>
                                </div>
                          </div>
                        </div>

                        <div id="roundInfo" class="stat" style="margin-left:8px;">
                          <div class="stat-label">Round Robin</div>
			  <div class="stat-value">disattivato</div>
			</div>
		  </div>

                  <!-- Griglia 2 colonne -->
                  <div class="host-grid">
                        <!-- Colonna sinistra -->
                        <div class="host-col">
                          <!-- Controlli -->
                          <div class="section">
                                <div class="section-title">Controlli</div>
                                <div class="host-controls">
                                  <select id="roundStrategy" class="btn">
                                        <option value="random">Ordine casuale</option>
                                        <option value="name">Ordine alfabetico (nome)</option>
                                  </select>
                                  <button class="btn" onclick="onHostStartRound()">Avvia RR</button>
                                  <button class="btn btn-ghost" onclick="onHostStopRound()">Stop RR</button>
                                  <button id="btnSkipNominator" class="btn">Salta turno nominatore</button>
                                  <button id="btnKickAnon" class="btn btn-danger">Elimina tutti</button>
                                  <label style="display:flex; align-items:center; gap:4px;">
                                    <input type="checkbox" id="toggleBidderDetails" onchange="onToggleBidderDetails()" />
                                    Dettagli bidder
                                  </label>
                                  <button class="btn btn-ghost" onclick="ensureWS(()=>ws.send(JSON.stringify({type:'host:get-users'})))">Aggiorna lista</button>
                                  <button class="btn btn-danger" onclick="onEndItem()">Chiudi asta</button>
                                </div>
                          </div>
                          <!-- Configurazione rapida -->
                          <div class="section">
                                <div class="section-title">Configurazione</div>
                                <div class="row">
                                  <input id="timerInp" type="number" min="5" value="12" placeholder="Countdown (s)" />
				  <button class="btn btn-primary" onclick="onSetTimer()">Imposta</button>
				</div>

				<div class="subgrid">
				  <div>
					<div class="subtle">Asta manuale</div>
					<div class="row">
					  <input id="itemNameInp" placeholder="Nome giocatore" />
					  <input id="roleInp" placeholder="Ruolo" />
					  <input id="teamInp" placeholder="Squadra" />
					  <input id="startPriceInp" type="number" value="0" placeholder="Base" />
					  <button class="btn" onclick="onStartItem()">Avvia</button>
					</div>
				  </div>

				  <div>
					<div class="subtle">Budget di default</div>

					<!-- Crediti iniziali a tutta larghezza -->
					<div class="row row--credits">
					  <input id="defCreditsInp" type="number" min="0" placeholder="Crediti iniziali" />
					</div>

					<!-- Slot tutti su una riga -->
					<div class="slots-row">
					  <input id="defPorInp" type="number" min="0" placeholder="POR (3)" />
					  <input id="defDifInp" type="number" min="0" placeholder="DIF (8)" />
					  <input id="defCenInp" type="number" min="0" placeholder="CEN (8)" />
					  <input id="defAttInp" type="number" min="0" placeholder="ATT (6)" />
					  <button class="btn" onclick="onSetBudgets()">Applica</button>
					</div>
				  </div>
				</div>
			  </div>

			  <!-- Lista giocatori (con ricerca/filtri/paginazione) -->
				<div class="section">
				  <div class="section-title">Giocatori</div>

				  <!-- Upload CSV -->
				  <div class="row">
					<input id="csvFile" type="file" accept=".csv" />
					<button class="btn" onclick="onUploadCsv()">Carica CSV</button>
				  </div>

				  <!-- Toolbar filtri -->
				  <div class="players-toolbar">
					<input id="playerSearch" type="search" placeholder="Cerca (nome, ruolo, squadra)…" oninput="onPlayersSearchInput(event)" />
					<select id="playerRoleFilter" onchange="onPlayersFilterChange()">
					  <option value="">Tutti i ruoli</option>
					  <option value="Portiere">Portiere</option>
					  <option value="Difensore">Difensore</option>
					  <option value="Centrocampista">Centrocampista</option>
					  <option value="Attaccante">Attaccante</option>
					</select>
					<select id="playerTeamFilter" onchange="onPlayersFilterChange()">
					  <option value="">Tutte le squadre</option>
					</select>
					<span class="players-stats">
					  <span id="playersCount">0</span> elementi
					</span>
					<span class="players-spacer"></span>
					<label>
					  Per pagina
					  <select id="playerPageSize" onchange="onPlayersPageSizeChange()">
						<option>10</option>
						<option selected>25</option>
						<option>50</option>
						<option>100</option>
					  </select>
					</label>
				  </div>

				  <div class="table-wrap">
					<table>
					  <thead>
						<tr>
						  <th style="width:64px">#</th>
						  <th data-sort="Nome"     onclick="onPlayersSort(this)">Nome</th>
						  <th data-sort="Ruolo"    onclick="onPlayersSort(this)">Ruolo</th>
						  <th data-sort="Squadra"  onclick="onPlayersSort(this)">Squadra</th>
						  <th data-sort="ValoreBase" onclick="onPlayersSort(this)">Base</th>
						  <th>Azioni</th>
						</tr>
					  </thead>
					  <tbody id="playersBody"></tbody>
					</table>
				  </div>

				  <!-- Paginazione -->
				  <div class="players-pager">
					<button class="btn" onclick="playersGoPage('first')">«</button>
					<button class="btn" onclick="playersGoPage('prev')">‹</button>
					<span>Pagina <b id="playersPageCur">1</b> / <b id="playersPageMax">1</b></span>
					<button class="btn" onclick="playersGoPage('next')">›</button>
					<button class="btn" onclick="playersGoPage('last')">»</button>
				  </div>
				</div>

			</div>

			<!-- Colonna destra -->
			<div class="host-col">
			  <!-- Asta corrente (dettaglio) -->
			  <div class="section">
				<div class="section-title">Asta corrente</div>
                                <div class="pill-row">
                                  <span class="pill-host"><b>Ruolo</b> <span id="itemRoleHost">—</span></span>
                                  <span class="pill-host"><b>Squadra</b> <span id="itemTeamHost">—</span></span>
                                  <span class="pill-host"><b>Countdown</b> <span id="countdownHost">—</span></span>
                                  <span class="pill-host"><b>Prezzo</b> <span id="itemPriceHost">0</span></span>
                                  <span class="pill-host"><b>Top bidder</b> <span id="itemBidderHost">—</span></span>
                                  <span class="pill-host"><b>Countdown predef.</b> <span id="timerCur">12</span>s</span>
                                </div>
			  </div>
			</div>

			<!-- FULL WIDTH: Utenti -->
			<div class="section full">
			  <div class="section-title">Utenti</div>
			  <div class="table-wrap">
				<table>
				  <thead>
                                        <tr>
                                          <th>Nome</th><th>Ruolo</th><th>Stato</th><th>Crediti</th><th>Spesi</th><th>POR</th><th>DIF</th><th>CEN</th><th>ATT</th><th>Azioni</th>
                                        </tr>
                                  </thead>
                                  <tbody id="users"></tbody>
                                </table>
                          </div>
                        </div>
			
			<div class="section full" id="invitesSection">
			  <div class="section-title">Inviti</div>

			  <!-- Crea invito PRIMA che l'utente entri -->
			  <div class="row">
				<input id="invNameNew" placeholder="Nome partecipante" />
				<select id="invRoleNew">
				  <option value="bidder" selected>Partecipante</option>
				  <option value="monitor">Monitor</option>
				  <option value="host">Gestore</option>
				</select>
				<button class="btn" id="inviteCreateByNameBtn">Crea da nome</button>

				<span style="margin:0 8px;opacity:.5">oppure</span>

				<!-- (facoltativo) crea da utente già collegato -->
				<select id="inviteUserSelect"></select>
				<button class="btn" id="inviteCreateBtn">Crea per utente</button>

				<span class="players-spacer"></span>
				<button class="btn btn-ghost" id="inviteRefreshBtn">Aggiorna</button>
			  </div>

			  <div class="table-wrap">
				<table>
				  <thead>
					<tr><th>Partecipante</th><th>Link</th><th>Azioni</th></tr>
				  </thead>
				  <tbody id="invitesBody"></tbody>
				</table>
			  </div>
			</div>

			<!-- FULL WIDTH: Log -->
			<div class="section full">
			  <div class="section-title">Log</div>
			  <div class="table-wrap table-wrap--log">
				<table>
				  <thead>
					<tr><th>Ora</th><th>Evento</th><th>Oggetto</th><th>Utente</th><th>Puntata</th><th>Vincitore</th></tr>
				  </thead>
				  <tbody id="logBody"></tbody>
				</table>
			  </div>
			  <div class="section full">
				  <div class="section-title">Download log</div>
				  <div class="row">
					<select id="logFileSelect" style="min-width:240px"></select>
					<a id="logDownloadBtn" class="btn" href="#" download>Scarica</a>
					<button class="btn btn-ghost" onclick="loadLogList()">Aggiorna elenco</button>
				  </div>
				</div>
			</div>
		  </div>
		</div>

        <div class="card" id="bidderCard" style="display:none;">
          <h2>Partecipante</h2>
          <div>Ciao, <b id="meName">—</b></div>
          <div class="player-display">
            <img id="itemImgBid" class="player-photo" src="/placeholder.jpg" alt="" />
            <div class="player-info">
              <span id="itemNameBid">—</span>
              <div id="bidderMetaRow">Prezzo: <b id="itemPriceBid">0</b> — da <b id="itemBidderBid">—</b></div>
            </div>
          </div>
          <div id="bidderSecondaryInfo" class="bidder-secondary">
            <div id="bidderBudgetBox" class="info-box">
              <div><b>Crediti:</b> <span id="meCredits">0</span></div>
              <div><b>Max puntata:</b> <span id="meMaxBid">0</span></div>
              <div><b>Spesi:</b> <span id="meSpent">0</span></div>
            </div>
            <div id="bidderMetaBox" class="info-box">
              <div id="bidderCountdownRow">Countdown: <b id="countdownBid">—</b></div>
              <div id="bidderRoleRow" style="display:none;">Ruolo: <b id="itemRoleBid">—</b></div>
              <div id="bidderTeamRow" style="display:none;">Squadra: <b id="itemTeamBid">—</b></div>
              <div id="bidderLast3Row" style="display:none;">Ultimi 3: <b id="itemLast3Bid">—</b></div>
            </div>
          </div>
          <div class="row" id="bidInputRow">
            <input id="bidAmount" type="number" min="1" placeholder="Offerta precisa" />
            <button onclick="onBidCustom()">Punta</button>
          </div>
          <div class="quick-bid-wrap">
            <div class="quick-bid" role="toolbar" aria-label="Offerte rapide">
              <button class="qbtn q1"  onclick="onBidPlus(1)"  aria-label="Aggiungi 1">
                <span class="chip" aria-hidden="true">
                  <i class="fa-solid fa-plus"></i>
                </span><span class="label">+1</span>
              </button>
              <button class="qbtn q5" onclick="onBidPlus(5)" aria-label="Aggiungi 5">
                <span class="chip" aria-hidden="true">
                  <i class="fa-solid fa-plus"></i>
                </span><span class="label">+5</span>
              </button>
              <button class="qbtn q10" onclick="onBidPlus(10)" aria-label="Aggiungi 10">
                <span class="chip" aria-hidden="true">
                  <i class="fa-solid fa-bolt"></i>
                </span><span class="label">+10</span>
              </button>
            </div>
            <div id="bidderNominateBox" class="card" style="margin-top:12px; display:none;">
              <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
                <div><b>Tocca a:</b> <span id="roundWhoseTurn">—</span></div>
                <button id="openNomBtn" class="btn btn-primary" onclick="openNominateModal()">Scegli dalla lista</button>
              </div>
              <small>Puoi nominare solo nel tuo turno e quando non c’è un’asta in corso.</small>
            </div>
          </div>
          <div id="bidBottomBar" class="bid-bottom-bar">
            <input id="bidAmountMobile" type="text" inputmode="numeric" />
            <button class="btn" aria-label="Aumenta" onclick="onBidMobilePlus()">+</button>
          </div>
        </div>

                <!-- Bidder: modale scelta giocatore -->
		<div id="nominateModal" style="display:none; position:fixed; inset:0; z-index:9998;">
		  <div style="position:absolute; inset:0; background:rgba(0,0,0,.45)" onclick="closeNominateModal()"></div>
		  <div style="position:relative; z-index:1; max-width:1000px; width:92vw; margin:5vh auto; background:#fff; border-radius:12px; padding:16px; box-shadow:0 20px 60px rgba(0,0,0,.25);">
			<div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;">
			  <h3 style="margin:0;">Scegli un giocatore</h3>
			  <button class="btn" onclick="closeNominateModal()">Chiudi</button>
			</div>

			<!-- Toolbar filtri -->
			<div class="players-toolbar">
			  <input id="nomSearch" type="search" placeholder="Cerca (nome, ruolo, squadra)…" oninput="onNomSearchInput(event)" />
			  <select id="nomRoleFilter" onchange="onNomFiltersChange()">
				<option value="">Tutti i ruoli</option>
				<option value="Portiere">Portiere</option>
				<option value="Difensore">Difensore</option>
				<option value="Centrocampista">Centrocampista</option>
				<option value="Attaccante">Attaccante</option>
			  </select>
			  <select id="nomTeamFilter" onchange="onNomFiltersChange()">
				<option value="">Tutte le squadre</option>
			  </select>
			  <span><span id="nomCount">0</span> elementi</span>
			  <span class="players-spacer"></span>
			  <label>Per pagina
				<select id="nomPageSize" onchange="onNomPageSizeChange()">
				  <option>10</option>
				  <option selected>25</option>
				  <option>50</option>
				  <option>100</option>
				</select>
			  </label>
			</div>

			<div class="table-wrap" style="max-height:60vh;">
			  <table>
				<thead>
				  <tr>
					<th style="width:64px">#</th>
					<th>Nome</th>
					<th>Ruolo</th>
					<th>Squadra</th>
					<th>Base</th>
					<th style="width:120px">Azioni</th>
				  </tr>
				</thead>
				<tbody id="nomBody"></tbody>
			  </table>
			</div>

			<!-- Paginazione -->
			<div class="players-pager">
			  <button class="btn" onclick="nomGoPage('first')">«</button>
			  <button class="btn" onclick="nomGoPage('prev')">‹</button>
			  <span>Pagina <b id="nomPageCur">1</b> / <b id="nomPageMax">1</b></span>
			  <button class="btn" onclick="nomGoPage('next')">›</button>
			  <button class="btn" onclick="nomGoPage('last')">»</button>
			</div>
		  </div>
		</div>


       <div id="monitorCard" class="card" style="display:none; text-align:center">
		 <div class="monitor-topbar">
			  <button id="btnFullscreen" class="btn btn-ghost" type="button">Schermo intero</button>
			</div>
          <div class="monitor-stage">
			  <div class="mon-wrap">
				<div class="mon-card">
				  <div class="mon-title">
					<div id="monName" class="mon-name">—</div>
					<div class="mon-meta">
					  <span class="pill"><span class="dot"></span><b id="monRole">—</b></span>
					  <span class="pill"><span class="dot"></span>Squadra <b id="monTeam">—</b></span>
					</div>
				  </div>

				  <div class="mon-price-wrap">
					<div class="mon-ring" id="monRing">
					  <div class="mon-time" id="monTime">—</div>
					</div>
					<div class="mon-price" id="monPrice">0</div>
				  </div>

				  <div class="last3" id="last3Chips">
				  </div>
				</div>

				<div class="mon-card" style="display:grid; place-items:center;">
				  <img id="monImg" class="mon-img" alt="Immagine giocatore" src="/placeholder.jpg">
				</div>
			  </div>
			</div>
        </div>
      `;
      document.body.appendChild(root);
	  // --- Barra Logout globale (visibile per qualsiasi ruolo “dentro”)
		const logoutBar = document.createElement('div');
		logoutBar.className = 'logout-bar';
		logoutBar.innerHTML = `
		  <span>Sei connesso.</span>
		  <button class="btn btn-danger" id="logoutBtn">Logout</button>
		`;
		document.body.appendChild(logoutBar);
	  // Stato iniziale bidder: bottoni disabilitati e righe nascoste
	  setBidButtonsEnabled(false);
          const metaRowInit = document.getElementById('bidderMetaRow');
          const cntRowInit  = document.getElementById('bidderCountdownRow');
          const roleRowInit = document.getElementById('bidderRoleRow');
          const teamRowInit = document.getElementById('bidderTeamRow');
          const last3RowInit = document.getElementById('bidderLast3Row');
          if (metaRowInit) metaRowInit.style.display = 'none';
          if (cntRowInit)  cntRowInit.style.display  = 'none';
          if (roleRowInit) roleRowInit.style.display = 'none';
          if (teamRowInit) teamRowInit.style.display = 'none';
          if (last3RowInit) last3RowInit.style.display = 'none';

          const bidDesktop = document.getElementById('bidAmount');
          const bidMobile  = document.getElementById('bidAmountMobile');
          const syncBid = (src) => {
                const val = parseInt(src.value || '0', 10) || 0;
                if (bidDesktop && src !== bidDesktop) bidDesktop.value = String(val);
                if (bidMobile  && src !== bidMobile)  bidMobile.value  = String(val);
          };
          bidDesktop?.addEventListener('input', e => syncBid(e.target));
          bidMobile?.addEventListener('input', e => syncBid(e.target));
          bidMobile?.addEventListener('focus', e => e.target.select());
    }

    // Esporta solo le funzioni usate dai bottoni nel DOM
    window.onSetTimer = onSetTimer;
    window.onStartItem = onStartItem;
    window.onStartPlayer = onStartPlayer;
    window.onEndItem = onEndItem;
    window.onBidPlus = onBidPlus;
    window.onBidMobilePlus = onBidMobilePlus;
    window.onBidCustom = onBidCustom;
    window.onUploadCsv = onUploadCsv;
    window.onSetBudgets = onSetBudgets;
        window.onHostStartRound = onHostStartRound;
        window.onHostStopRound  = onHostStopRound;
        window.onToggleBidderDetails = onToggleBidderDetails;
  </script>
</head>
<body></body>
</html>

